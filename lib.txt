lib/
├── app.dart
├── firebase_options.dart
├── main.dart
├── models/
│   ├── cart_item.dart
│   ├── category.dart
│   ├── coupon.dart
│   ├── discount.dart
│   ├── location.dart
│   ├── product.dart
│   ├── sale.dart
│   ├── sales_chart_data.dart
│   └── user.dart
├── routes.dart
├── services/
│   ├── auth_service.dart
│   ├── barcode_service.dart
│   ├── firestore_service.dart
│   └── pdf_service.dart
├── viewmodels/
│   ├── auth_vm.dart
│   ├── discount_vm.dart
│   ├── refund_vm.dart
│   ├── sales_vm.dart
│   └── stock_vm.dart
├── views/
│   ├── admin/
│   │   ├── admin_home_screen.dart
│   │   ├── location_management.dart
│   │   ├── product_management.dart
│   │   ├── reports_screen copy.dart
│   │   ├── reports_screen.dart
│   │   ├── stock_management.dart
│   │   └── users_management.dart
│   ├── agent/
│   │   ├── agent_home_screen.dart
│   │   ├── refund_screen.dart
│   │   ├── sales_history_screen.dart
│   │   ├── sales_screen.dart
│   │   └── stock_screen.dart
│   ├── login_screen.dart
│   └── signup_screen.dart
└── widgets/
    ├── discount_badge.dart
    ├── payment_section.dart
    ├── product_details_card.dart
    ├── refund_product_card.dart
    ├── role_based_ui.dart
    └── sale_item.dart

app.dart:

# app.dart
import 'package:flutter/material.dart';
import 'package:salesgo/views/admin/admin_home_screen.dart';
import 'package:salesgo/views/admin/users_management.dart';
import 'package:salesgo/views/agent/agent_home_screen.dart';
import 'package:salesgo/views/agent/sales_history_screen.dart';
import 'package:salesgo/views/agent/stock_screen.dart';
import 'package:salesgo/views/login_screen.dart';
import 'widgets/role_based_ui.dart';

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Mobile SalesGo',
      theme: ThemeData(primarySwatch: Colors.blue),
      initialRoute: '/',
      routes: {
        '/': (context) => const RoleBasedUI(),
        '/login': (context) => const LoginScreen(),
        '/history': (context) => const HistoryScreen(),
        '/stock': (context) => const StockScreen(),
        '/users': (context) => const UsersScreen(),
        '/admin': (context) => const AdminHomeScreen(),
        '/agent': (context) => const AgentHomeScreen(),
      },
    );
  }
}

firebase_options.dart:

# firebase_options.dart
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyCtAgAUfyI9tQX9XXCSPRTerqQsBh1LbXk',
    appId: '1:841065984080:web:74416838864f3d38836155',
    messagingSenderId: '841065984080',
    projectId: 'salesgo-49e56',
    authDomain: 'salesgo-49e56.firebaseapp.com',
    storageBucket: 'salesgo-49e56.firebasestorage.app',
    measurementId: 'G-VZ6MHV30BT',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyB0FuETZfLqhEF9Tglmo2DqOYoefa6UyjI',
    appId: '1:841065984080:android:e356f68a50456f32836155',
    messagingSenderId: '841065984080',
    projectId: 'salesgo-49e56',
    storageBucket: 'salesgo-49e56.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyDZLay0tHq0wLc0rAJ_z0KGA_9aW8fpv8U',
    appId: '1:841065984080:ios:2b7a1fa1b210daba836155',
    messagingSenderId: '841065984080',
    projectId: 'salesgo-49e56',
    storageBucket: 'salesgo-49e56.firebasestorage.app',
    iosBundleId: 'com.example.salesgo',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyDZLay0tHq0wLc0rAJ_z0KGA_9aW8fpv8U',
    appId: '1:841065984080:ios:2b7a1fa1b210daba836155',
    messagingSenderId: '841065984080',
    projectId: 'salesgo-49e56',
    storageBucket: 'salesgo-49e56.firebasestorage.app',
    iosBundleId: 'com.example.salesgo',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyCtAgAUfyI9tQX9XXCSPRTerqQsBh1LbXk',
    appId: '1:841065984080:web:d629584b20a21e2c836155',
    messagingSenderId: '841065984080',
    projectId: 'salesgo-49e56',
    authDomain: 'salesgo-49e56.firebaseapp.com',
    storageBucket: 'salesgo-49e56.firebasestorage.app',
    measurementId: 'G-ESP4M4W4W9',
  );

}

main.dart:

# main.dart
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:salesgo/firebase_options.dart';
import 'package:salesgo/viewmodels/discount_vm.dart';
import 'package:salesgo/viewmodels/refund_vm.dart';
import 'package:salesgo/viewmodels/sales_vm.dart';
import 'package:salesgo/viewmodels/stock_vm.dart';
import 'package:salesgo/views/admin/admin_home_screen.dart';
import 'package:salesgo/views/admin/users_management.dart';
import 'package:salesgo/views/agent/agent_home_screen.dart';
import 'package:salesgo/views/agent/sales_history_screen.dart';
import 'package:salesgo/views/agent/stock_screen.dart';
import 'package:salesgo/views/signup_screen.dart';
import 'package:salesgo/widgets/role_based_ui.dart';
import 'viewmodels/auth_vm.dart';
import 'services/auth_service.dart';
import 'services/firestore_service.dart';
import 'views/login_screen.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  try {
    if (Firebase.apps.isEmpty) {
      await Firebase.initializeApp(
        options: DefaultFirebaseOptions.currentPlatform,
      );
    }
  } catch (e) {
    print('Firebase initialization error: $e');
  }
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => AuthViewModel(authService: FirebaseAuthService())),
        Provider(create: (_) => FirestoreService()),
        ChangeNotifierProvider(create: (context) => SalesViewModel(
          firestoreService: context.read<FirestoreService>(),
        )),
        ChangeNotifierProvider(create: (context) => StockViewModel(
          firestoreService: context.read<FirestoreService>(),
        )),
        ChangeNotifierProvider(create: (context) => DiscountViewModel(
          firestoreService: context.read<FirestoreService>(),
        )),
        ChangeNotifierProvider(create: (context) => RefundViewModel(
          firestoreService: context.read<FirestoreService>(),
        )),        
      ],
      child: const MyApp(),
    ),
  );
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return Consumer<AuthViewModel>(
      builder: (context, authVM, _) {
        return MaterialApp(
          title: 'Ventes Porte-à-Porte',
          theme: ThemeData(primarySwatch: Colors.blue),
          // Remove initialRoute and home, handle everything through routes
          routes: {
            '/': (context) => _buildInitialScreen(authVM),
            '/login': (context) => const LoginScreen(),
            '/signup': (context) => const SignupScreen(),
            '/history': (context) => const HistoryScreen(),
            '/stock': (context) => const StockScreen(),
            '/users': (context) => const UsersScreen(),
            '/admin': (context) => const AdminHomeScreen(),
            '/agent': (context) => const AgentHomeScreen(),
          },
        );
      },
    );
  }

  Widget _buildInitialScreen(AuthViewModel authVM) {
    if (authVM.isLoading) {
      return const Scaffold(body: Center(child: CircularProgressIndicator()));
    }
    return authVM.currentUser == null 
        ? const LoginScreen()
        : const RoleBasedUI();
  }
}

routes.dart:

# routes.dart
import 'package:salesgo/views/admin/reports_screen.dart';

import 'views/admin/admin_home_screen.dart';
import 'views/agent/agent_home_screen.dart';
import 'views/agent/sales_history_screen.dart';
import 'views/agent/stock_screen.dart';
import 'views/admin/users_management.dart';

final appRoutes = {
  '/history': (context) => const HistoryScreen(),
  '/stock': (context) => const StockScreen(),
  '/users': (context) => const UsersScreen(),
  '/admin': (context) => const AdminHomeScreen(),
  '/agent': (context) => const AgentHomeScreen(),
  '/reports': (context) => const ReportsScreen(),

};

models\cart_item.dart:

# models\cart_item.dart
import 'package:salesgo/models/discount.dart';
import 'package:salesgo/models/product.dart';


class CartItem {
  final String id;
  final Product product;
  Discount? discount;

  CartItem({
    required this.id,
    required this.product,
    this.discount,
  });
}


models\category.dart:

# models\category.dart
import 'package:cloud_firestore/cloud_firestore.dart';

class Category {
  final String id;
  final String name;
  final DocumentReference? reference; // Add reference field
  final DateTime createdAt;

  Category({
    required this.id,
    required this.name,
    this.reference,
    required this.createdAt,
  });

  factory Category.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return Category(
      id: doc.id,
      name: data['name'] ?? '',
      reference: doc.reference,
      createdAt: (data['createdAt'] as Timestamp).toDate(),
    );
  }

  Map<String, dynamic> toMap() => {
    'name': name,
    //'imageUrl': imageUrl,
    'createdAt': FieldValue.serverTimestamp(),
  };
}

models\coupon.dart:

# models\coupon.dart
class Coupon {
  final String id;
  final String code;
  final double value;
  final DateTime expiration;
  final bool isUsed;

  Coupon({
    required this.id,
    required this.code,
    required this.value,
    required this.expiration,
    required this.isUsed,
  });

  factory Coupon.fromFirestore(Map<String, dynamic> data) {
    return Coupon(
      id: data['id'],
      code: data['code'],
      value: data['value'].toDouble(),
      expiration: data['expiration'].toDate(),
      isUsed: data['isUsed'],
    );
  }
}

models\discount.dart:

# models\discount.dart
import 'package:cloud_firestore/cloud_firestore.dart';

class Discount {
  final String id;
  final DocumentReference categoryRef;
  final DateTime? startDate;
  final DateTime? endDate;
  final double value;
  final String type;
  final bool hasDateRange;
  final String name;
  final DocumentReference? reference;

  Discount({
    required this.id,
    required this.categoryRef,
    this.startDate,
    this.endDate,
    required this.value,
    required this.hasDateRange,
    required this.type,
    required this.name,
    this.reference,
  });

  factory Discount.fromFirestore(DocumentSnapshot doc) {
    try {
      final data = doc.data() as Map<String, dynamic>;
      
      return Discount(
        id: doc.id,
        categoryRef: data['categoryRef'] as DocumentReference,
        startDate: data['hasDateRange'] ? (data['startDate'] as Timestamp).toDate() : null,
        endDate: data['hasDateRange'] ? (data['endDate'] as Timestamp).toDate() : null,
        value: (data['value'] as num).toDouble(),
        type: data['type'] as String,
        hasDateRange: data['hasDateRange'] as bool? ?? false,
        name: data['name'] as String? ?? '',
        reference: doc.reference,
      );
    } catch (e) {
      throw FormatException('Failed to parse Discount: $e');
    }
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'categoryRef': categoryRef,
      if (hasDateRange && startDate != null) 'startDate': Timestamp.fromDate(startDate!),
      if (hasDateRange && endDate != null) 'endDate': Timestamp.fromDate(endDate!),
      'value': value,
      'type': type,
      'hasDateRange': hasDateRange,
      'name': name,
    };
  }

  bool get isActive {
    if (!hasDateRange) return true;
    if (startDate == null || endDate == null) return false;
    final now = DateTime.now();
    return now.isAfter(startDate!) && now.isBefore(endDate!);
  }

  @override
  String toString() {
    return 'Discount(id: $id, name: $name, value: $value$type, '
           'active: ${hasDateRange ? '${startDate?.toIso8601String()} to ${endDate?.toIso8601String()}' : 'Always active'})';
  }
}

models\location.dart:

# models\location.dart
import 'package:cloud_firestore/cloud_firestore.dart';

class Location {
  final String id;
  final String name;
  final String type; // Added location type
  final String? assignedAgentId;
  final DateTime createdAt;

  Location({
    required this.id,
    required this.name,
    required this.type,
    this.assignedAgentId,
    required this.createdAt,
  });

  factory Location.fromFirestore(Map<String, dynamic> data) {
    return Location(
      id: data['id'],
      name: data['name'],
      type: data['type'] ?? 'van', // Default type
      assignedAgentId: data['assignedAgentId'],
      createdAt: (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
    );
  }

  Map<String, dynamic> toMap() => {
    'id': id,
    'name': name,
    'type': type,
    'assignedAgentId': assignedAgentId,
    'createdAt': createdAt,

  };
}

models\product.dart:

# models\product.dart
import 'package:cloud_firestore/cloud_firestore.dart';

class Product {
  final String id;
  final String name;
  final double price;
  final DocumentReference categoryRef;
  final String barcode;
  final String? imageUrl;
  final List<String> availableLocations;
  final DocumentReference? reference;
  //final DateTime createdAt;

 

  Product({
    required this.id,
    required this.name,
    required this.price,
    required this.categoryRef,
    required this.barcode,
    this.imageUrl,
    this.availableLocations = const [],
    this.reference,
    //required this.createdAt,

  });

  factory Product.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>? ?? {};
    return Product(
      id: doc.id,
      name: data['name'] as String? ?? '',
      price: (data['price'] as num?)?.toDouble() ?? 0.0,
      categoryRef: data['categoryRef'] as DocumentReference,
      barcode: data['barcode'] as String? ?? '',
      imageUrl: data['imageUrl'] as String?,
      availableLocations: List<String>.from(data['availableLocations'] ?? []),
      //createdAt:  (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),

    );
  }

  factory Product.fromMap(Map<String, dynamic> map, String id) {
    return Product(
      id: map['id'] as String? ?? '',
      name: map['name'] as String? ?? '',
      price: (map['price'] as num?)?.toDouble() ?? 0.0,
      categoryRef: map['categoryRef'] as DocumentReference, 
      barcode: map['barcode'] as String? ?? '',
      imageUrl: map['imageUrl'] as String?,
      //createdAt: (map['createdAt'] as Timestamp?)!.toDate(),
      
    );
  }
  
  Map<String, dynamic> toMap() => {
    'id': id,
    'name': name,
    'price': price,
    'categoryRef': categoryRef,
    'barcode': barcode,
    'imageUrl': imageUrl, 
    'availableLocations': availableLocations,
    //'createdAt': FieldValue.serverTimestamp(),

  };

  // Add barcode validation method
  static String? validateBarcode(String? value) {
    if (value == null || value.isEmpty) return 'Barcode is required';
    if (value.length < 3) return 'Barcode too short (min 3 chars)';
    if (!RegExp(r'^[a-zA-Z0-9]+$').hasMatch(value)) {
      return 'Only alphanumeric characters allowed';
    }
    return null;
  }

}

models\sale.dart:

# models\sale.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:salesgo/models/product.dart';

class Sale {
  final String id;
  final String agentId;
  final String locationId;
  final DateTime date;
  final List<Product> products;
  final double totalAmount;
  final String paymentMethod;
  final String? couponCode;

  Sale({
    required this.id,
    required this.agentId,
    required this.locationId,
    required this.date,
    required this.products,
    required this.totalAmount,
    required this.paymentMethod,
    this.couponCode,
  });

  // Convert Sale object to Map for Firestore
  Map<String, dynamic> toMap() => {
    'id': id,
    'agentId': agentId,
    'locationId': locationId,
    'date': date,
    'products': products.map((p) => p.toMap()).toList(),
    'totalAmount': totalAmount,
    'paymentMethod': paymentMethod,
    'couponCode': couponCode,
  };

  // Create Sale object from Firestore document
  factory Sale.fromFirestore(DocumentSnapshot<Map<String, dynamic>> doc) {
    final data = doc.data() ?? {};
    return Sale(
      id: doc.id,
      agentId: data['agentId'] as String? ?? '',
      locationId: data['locationId'] ?? '',
      date: (data['date'] as Timestamp?)?.toDate() ?? DateTime.now(),
      products: (data['products'] as List?)?.map((p) => 
        Product.fromMap(p as Map<String, dynamic>, p['id'] as String? ?? '')).toList() ?? [],
      totalAmount: (data['totalAmount'] as num?)?.toDouble() ?? 0.0,
      paymentMethod: data['paymentMethod'] as String? ?? '',
      couponCode: data['couponCode'] as String?,
    );
  }

  static List<Product> _parseProducts(dynamic productsData) {
    if (productsData is! List) return [];
    return productsData.map((p) => Product.fromMap(p as Map<String, dynamic>, p['id'] as String? ?? '')).toList();
  }

}

models\sales_chart_data.dart:

# models\sales_chart_data.dart
class SalesChartData {
  final String periodKey;
  final String agentName;
  final double amount;
  final int xIndex;

  SalesChartData({
    required this.periodKey,
    required this.agentName,
    required this.amount,
    required this.xIndex,
  });

  String get key => '${periodKey}_$agentName';
}

models\user.dart:

# models\user.dart
import 'package:cloud_firestore/cloud_firestore.dart';

class AppUser {
  final String uid;
  final String email;
  final String role;
  final String? assignedLocationId;
  final String name;
  final DateTime createdAt;

  AppUser({
    required this.uid,
    required this.email,
    required this.role,
    this.assignedLocationId,
    required this.name,
    required this.createdAt,
  });

  factory AppUser.fromFirestore(Map<String, dynamic> data) {
    return AppUser(
      uid: data['uid'] ?? '',
      email: data['email'] ?? '',
      role: data['role'] ?? 'agent',
      assignedLocationId: data['assignedLocationId'],
      name: data['name'] ?? 'Agent Name',
      createdAt: (data['createdAt'] as Timestamp).toDate(),
    );
  }

  Map<String, dynamic> toMap() => {
    'uid': uid,
    'email': email,
    'role': role,
    'assignedLocationId': assignedLocationId,
    'name': name,
    'createdAt': createdAt,
  };

}

services\auth_service.dart:

# services\auth_service.dart
import 'package:cloud_firestore/cloud_firestore.dart' show FieldValue, FirebaseFirestore;
import 'package:firebase_auth/firebase_auth.dart';

abstract class AuthService {
  Future<User?> signIn(String email, String password);
  Future<User?> signUp(String email, String password, String name, String role);
  Future<void> signOut();
  Stream<User?> get authStateChanges;
}

class FirebaseAuthService implements AuthService {
  final FirebaseAuth _auth = FirebaseAuth.instance;

  @override
  Future<User?> signIn(String email, String password) async {
    try {
      // Corrected: Store the UserCredential properly
      final UserCredential userCredential = await _auth.signInWithEmailAndPassword(
        email: email,
        password: password,
      );
      // Return the User object from UserCredential
      return userCredential.user;
    } on FirebaseAuthException catch (e) {
      throw _handleAuthError(e);
    } catch (e) {
      throw Exception('Login error: $e');
    }
  }

  String _handleAuthError(FirebaseAuthException e) {
    switch (e.code) {
      case 'user-not-found':
        return 'No user found with this email.';
      case 'wrong-password':
        return 'Incorrect password.';
      case 'invalid-email':
        return 'Invalid email format.';
      default:
        return 'Login failed: ${e.message}';
    }
  }

    @override
  Future<User?> signUp(String email, String password,String name, String role) async {
    try {
      final UserCredential userCredential = 
          await _auth.createUserWithEmailAndPassword(
        email: email,
        password: password,
      );
      
      // Create user document in Firestore
      await _createUserDocument(userCredential.user!, name, role);
      
      return userCredential.user;
    } on FirebaseAuthException catch (e) {
      throw _handleAuthError(e);
    }
  }

  Future<void> _createUserDocument(User user, String name, String role) async {
    await FirebaseFirestore.instance.collection('users').doc(user.uid).set({
      'uid': user.uid,
      'email': user.email,
      'role': role,
      'name': name,
      'createdAt': FieldValue.serverTimestamp(),
    });
  }


  @override
  Future<void> signOut() => _auth.signOut();

  @override
  Stream<User?> get authStateChanges => _auth.authStateChanges();

Future<void> resetPassword(String email) async {
  await _auth.sendPasswordResetEmail(email: email);
}


}

services\barcode_service.dart:

# services\barcode_service.dart
import 'dart:async';

import 'package:mobile_scanner/mobile_scanner.dart';

class BarcodeService {
  Future<String?> scanBarcode() async {
    final completer = Completer<String?>();
    final controller = MobileScannerController();

    controller.barcodes.listen((barcode) {
      if (barcode.barcodes.isNotEmpty) {
        completer.complete(barcode.barcodes.first.rawValue);
        controller.stop();
      }
    });

    await controller.start();
    final result = await completer.future;
    controller.dispose();
    return result;
  }
}

services\firestore_service.dart:

# services\firestore_service.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:salesgo/models/discount.dart';
import '../models/product.dart';
import '../models/sale.dart';

class FirestoreService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  Future<Product> addProduct({
    required String name,
    required double price,
    required String categoryId,
    required String barcode,
    String? imageUrl,
  }) async {
    final cleanedBarcode = barcode.trim().toUpperCase();
    
    if (!await isBarcodeUnique(cleanedBarcode)) {
      throw 'Product with barcode "$cleanedBarcode" already exists';
    }

    final productRef = _firestore.collection('products').doc();
    final product = Product(
      id: productRef.id,
      name: name,
      price: price,
      categoryRef: _firestore.collection('categories').doc(categoryId),
      barcode: cleanedBarcode,
      imageUrl: imageUrl,

    );

    await productRef.set(product.toMap());
    return product;
  }

  Future<void> updateProduct({
    required String productId,
    required String name,
    required double price,
    required String categoryId,
    required String barcode,
    String? imageUrl,
  }) async {
    final cleanedBarcode = barcode.trim().toUpperCase();
    
    if (!await isBarcodeUnique(cleanedBarcode, excludeProductId: productId)) {
      throw 'Product with barcode "$cleanedBarcode" already exists';
    }

    await _firestore.collection('products').doc(productId).update({
      'name': name,
      'price': price,
      'categoryRef': _firestore.collection('categories').doc(categoryId),
      'barcode': cleanedBarcode,
      'imageUrl': imageUrl,
      'updatedAt': FieldValue.serverTimestamp(),
    });
  }

  Future<bool> isBarcodeUnique(String barcode, {String? excludeProductId}) async {
    final query = _firestore.collection('products')
      .where('barcode', isEqualTo: barcode.trim().toUpperCase());

    if (excludeProductId != null) {
      query.where(FieldPath.documentId, isNotEqualTo: excludeProductId);
    }

    final snapshot = await query.limit(1).get();
    return snapshot.docs.isEmpty;
  }



  // Produits
  Future<Product?> getProductByBarcode(String barcode) async {
    final snapshot = await FirebaseFirestore.instance
        .collection('products')
        .where('barcode', isEqualTo: barcode)
        .limit(1)
        .get();

    return snapshot.docs.isEmpty 
        ? null 
        : Product.fromFirestore(snapshot.docs.first);
  }

  // For getting products by category
  Future<List<Product>> getProductsByCategory(DocumentReference categoryRef) async {
    final snapshot = await FirebaseFirestore.instance
        .collection('products')
        .where('categoryRef', isEqualTo: categoryRef)
        .get();

    return snapshot.docs.map((doc) => Product.fromFirestore(doc)).toList();
  } 



  Future<DocumentReference> getCategoryReference(String categoryId) async {
    return FirebaseFirestore.instance.collection('categories').doc(categoryId);
  }

  // Ventes
  Future<void> recordSale(Sale sale) async {
    await _firestore.collection('sales').add(sale.toMap());
  }

  Stream<Map<String, int>> getMonthlySales(String locationId, DateTime firstDayOfMonth) {
    return FirebaseFirestore.instance
        .collection('sales')
        .where('locationId', isEqualTo: locationId)
        .where('date', isGreaterThanOrEqualTo: Timestamp.fromDate(firstDayOfMonth))
        .snapshots()
        .map((snapshot) {
          debugPrint('Fetched sales count: ${snapshot.docs.length}');
          
          for (final doc in snapshot.docs) {
            debugPrint('Fetched sale: ${doc.data()}');
          }

          final monthlySales = <String, int>{};
          for (final doc in snapshot.docs) {
            final sale = doc.data() as Map<String, dynamic>;
            final List<dynamic> products = sale['products'] ?? [];

            for (final product in products) {
              final productId = product['id'] as String;

              //  Check if 'quantity' exists, else default to 1
              final quantity = (product['quantity'] != null) 
                  ? product['quantity'] as int 
                  : 1;

              monthlySales[productId] = (monthlySales[productId] ?? 0) + quantity;
            }
          }
          return monthlySales;
        });
  }




  // Stocks
  Stream<Map<String, int>> getLocationStock(String locationId) {
    return _firestore.collection('locations/$locationId/stock')
      .snapshots()
      .map((snapshot) => {
        for (var doc in snapshot.docs)
          doc.id: doc.data()['quantity'] as int
      });
  }

  Future<QuerySnapshot<Map<String, dynamic>>> getActiveDiscounts(DateTime now) async {
    return await _firestore.collection('discounts')
        .where('startDate', isLessThanOrEqualTo: now)
        .where('endDate', isGreaterThanOrEqualTo: now)
        .get();
  }

  // For getting discounts by category
  Future<List<Discount>> getDiscountsByCategory(DocumentReference categoryRef) async {
    final snapshot = await FirebaseFirestore.instance
        .collection('discounts')
        .where('categoryRef', isEqualTo: categoryRef)
        .get();

    return snapshot.docs.map((doc) => Discount.fromFirestore(doc)).toList();
  } 

  Future<List<Sale>> getAgentSales(String agentId) async {
    final snapshot = await _firestore.collection('sales')
      .where('agentId', isEqualTo: agentId)
      .withConverter<Sale>(
        fromFirestore: (doc, _) => Sale.fromFirestore(doc),
        toFirestore: (sale, _) => sale.toMap(),
      )
      .get();
      
    return snapshot.docs.map((doc) => doc.data()).toList();
  }
  
  Future<List<Sale>> getSalesForAgent(String agentId) async {
    try {
      final QuerySnapshot<Map<String, dynamic>> snapshot = await FirebaseFirestore.instance
          .collection('sales')
          .where('agentId', isEqualTo: agentId)
          .get();

      return snapshot.docs.map((doc) => Sale.fromFirestore(doc)).toList();
    } catch (e) {
      debugPrint('Error fetching sales: $e');
      return []; // Return empty list on error
    }
  }

  Future<void> processRefund({
    required List<Product> products,
    required String agentId,
    required String locationId,
  }) async {
    try {
      final batch = FirebaseFirestore.instance.batch();
      final refundDoc = FirebaseFirestore.instance.collection('refunds').doc();
      
      // Create refund record
      batch.set(refundDoc, {
        'products': products.map((p) => p.toMap()).toList(),
        'totalAmount': products.fold(0.0, (sum, p) => sum + p.price),
        'agentId': agentId,
        'locationId': locationId,
        'date': FieldValue.serverTimestamp(),
        'status': 'completed',
      });

      // Update inventory for each product
      for (final product in products) {
        final productRef = FirebaseFirestore.instance
            .collection('products')
            .doc(product.id);
        
        batch.update(productRef, {
          'stock': FieldValue.increment(1),
        });
      }

      await batch.commit();
    } catch (e) {
      throw Exception('Failed to process refund: $e');
    }
  }

  // Categories
  Future<void> addCategory(Map<String, dynamic> categoryData) async {
    await _firestore.collection('categories').add(categoryData);
  }

  Stream<QuerySnapshot> getCategories() {
    return _firestore.collection('categories').snapshots();
  }

  Future<void> deleteCategory(String categoryId) async {
    await _firestore.collection('categories').doc(categoryId).delete();
  }

  // Discounts
  Future<void> addDiscount(Map<String, dynamic> discountData) {
    return _firestore.collection('discounts').add(discountData);
  }

  Future<void> updateDiscount(String id, Map<String, dynamic> discountData) {
    return _firestore.collection('discounts').doc(id).update(discountData);
  }

  Stream<QuerySnapshot> getDiscounts() {
    return _firestore.collection('discounts').snapshots();
  }

  Future<void> deleteDiscount(String id) {
    return _firestore.collection('discounts').doc(id).delete();
  }
}




services\pdf_service.dart:

# services\pdf_service.dart
import 'package:pdf/widgets.dart' as pw;
import 'package:salesgo/models/sale.dart';

class PdfService {
  pw.Document generateInvoice(Sale sale) {
    final pdf = pw.Document();
    
    pdf.addPage(
      pw.Page(
        build: (context) => pw.Column(
          children: [
            pw.Header(text: 'Facture #${sale.id}'),
            pw.ListView.builder(
              itemCount: sale.products.length,
              itemBuilder: (context, index) => pw.Text(
                sale.products[index].name,
              ),
            ),
          ],
        ),
      ),
    );
    
    return pdf;
  }
}

viewmodels\auth_vm.dart:

# viewmodels\auth_vm.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import '../services/auth_service.dart';
import '../models/user.dart';

class AuthViewModel with ChangeNotifier {
  final AuthService authService;
  bool _isLoading = false;
  AppUser? _currentUser;
  String? _userRole;
  String? _errorMessage;

  AuthViewModel({required this.authService});

  AppUser? get currentUser => _currentUser;
  String? get userRole => _userRole;
  String? get errorMessage => _errorMessage;

  bool get isLoading => _isLoading;

  Future<void> signIn(String email, String password) async {
    try {
      _isLoading = true;
      notifyListeners();
      
      final user = await authService.signIn(email, password);
      if (user != null) {
        final userDoc = await FirebaseFirestore.instance
            .collection('users')
            .doc(user.uid)
            .get();
        
        if (!userDoc.exists) throw Exception('User document not found');
        if (userDoc.data() == null) {throw Exception("Les données utilisateur sont nulles !");}
        _currentUser = AppUser.fromFirestore(userDoc.data()!);
        _userRole = userDoc.data()!['role'];
      }
    } catch (e) {
      _errorMessage = e.toString();
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }


  Future<void> signOut() async {
    await authService.signOut();
    _currentUser = null;
    _userRole = null;
    notifyListeners();
  }

  Stream<AppUser?> get authStateChanges => authService.authStateChanges
      .asyncMap((user) => user != null ? _getUserData(user.uid) : null);

  Future<AppUser?> _getUserData(String uid) async {
    final doc = await FirebaseFirestore.instance.collection('users').doc(uid).get();
    return doc.exists ? AppUser.fromFirestore(doc.data()!) : null;
  }

  Future<void> signUp(
    String email, 
    String password,
    String name,
    String role,
  ) async {
    try {
      final user = await authService.signUp(email, password, name, role);
      if (user != null) {
        _currentUser = AppUser(
          uid: user.uid,
          email: user.email ?? '',
          name: name,
          role: role,
          createdAt: DateTime.now(),
        );
        _userRole = role;
      }
    } catch (e) {
      _errorMessage = e.toString();
    }
    notifyListeners();
  }

  // Add this method to update the current user
  Future<void> updateCurrentUser(AppUser? user) async {
    _currentUser = user;
    _userRole = user?.role;
    notifyListeners();
  }

  // Add this method to refresh user data from Firestore
  Future<void> refreshUserData() async {
    if (_currentUser == null) return;
    
    try {
      final userDoc = await FirebaseFirestore.instance
          .collection('users')
          .doc(_currentUser!.uid)
          .get();
      
      if (userDoc.exists) {
        await updateCurrentUser(AppUser.fromFirestore(userDoc.data()!));
      }
    } catch (e) {
      debugPrint('Error refreshing user data: $e');
    }
  }


}

viewmodels\discount_vm.dart:

# viewmodels\discount_vm.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import '../services/firestore_service.dart';
import '../models/discount.dart';

class DiscountViewModel with ChangeNotifier {
  final FirestoreService _firestoreService;
  List<Discount> _activeDiscounts = [];
  bool _isLoading = false;
  String? _error;

  DiscountViewModel({required FirestoreService firestoreService})
      : _firestoreService = firestoreService;

  List<Discount> get activeDiscounts => List.unmodifiable(_activeDiscounts);
  bool get isLoading => _isLoading;
  String? get error => _error;

  Future<void> loadActiveDiscounts() async {
    _setLoading(true);
    _error = null;
    
    try {
      final now = DateTime.now();
      final snapshot = await _firestoreService.getActiveDiscounts(now);
      
      _activeDiscounts = snapshot.docs.map((doc) {
        try {
          return Discount.fromFirestore(doc);
        } catch (e) {
          debugPrint('Error parsing discount document ${doc.id}: $e');
          return null;
        }
      }).whereType<Discount>().toList();
      
      notifyListeners();
    } catch (e) {
      _error = 'Failed to load discounts: ${e.toString()}';
      debugPrint(_error!);
      notifyListeners();
      rethrow;
    } finally {
      _setLoading(false);
    }
  }

  Future<List<Discount>> getDiscountsForCategory(DocumentReference categoryRef) async {
    _setLoading(true);
    try {
      final discounts = await _firestoreService.getDiscountsByCategory(categoryRef);
      return discounts.docs.map((doc) => Discount.fromFirestore(doc)).toList();
    } catch (e) {
      debugPrint('Error loading discounts for category: $e');
      rethrow;
    } finally {
      _setLoading(false);
    }
  }

  Future<void> addDiscount(Discount discount) async {
    _setLoading(true);
    try {
      await _firestoreService.addDiscount(discount.toMap());
      await loadActiveDiscounts(); // Refresh the list
    } catch (e) {
      _error = 'Failed to add discount: ${e.toString()}';
      debugPrint(_error!);
      rethrow;
    } finally {
      _setLoading(false);
    }
  }

  Future<void> updateDiscount(Discount discount) async {
    _setLoading(true);
    try {
      await _firestoreService.updateDiscount(discount.id, discount.toMap());
      await loadActiveDiscounts(); // Refresh the list
    } catch (e) {
      _error = 'Failed to update discount: ${e.toString()}';
      debugPrint(_error!);
      rethrow;
    } finally {
      _setLoading(false);
    }
  }

  Future<void> deleteDiscount(String discountId) async {
    _setLoading(true);
    try {
      await _firestoreService.deleteDiscount(discountId);
      _activeDiscounts.removeWhere((d) => d.id == discountId);
      notifyListeners();
    } catch (e) {
      _error = 'Failed to delete discount: ${e.toString()}';
      debugPrint(_error!);
      rethrow;
    } finally {
      _setLoading(false);
    }
  }

  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }

  void clearError() {
    _error = null;
    notifyListeners();
  }
}

extension on List<Discount> {
  get docs => null;
}

viewmodels\refund_vm.dart:

# viewmodels\refund_vm.dart
import 'package:flutter/material.dart';
import 'package:salesgo/models/product.dart';
import 'package:salesgo/services/firestore_service.dart';

class RefundViewModel with ChangeNotifier {
  final FirestoreService _firestoreService;
  final List<Product> _refundItems = [];
  
  RefundViewModel({required FirestoreService firestoreService})
      : _firestoreService = firestoreService;

  List<Product> get refundItems => _refundItems;
  
  double get totalRefundAmount => _refundItems.fold(
    0.0, 
    (sum, product) => sum + product.price
  );

  void addToRefund(Product product) {
    _refundItems.add(product);
    notifyListeners();
  }

  void removeFromRefund(int index) {
    _refundItems.removeAt(index);
    notifyListeners();
  }

  void clearRefund() {
    _refundItems.clear();
    notifyListeners();
  }

  Future<void> processRefund({
    required String agentId,
    required String locationId,
  }) async {
    if (_refundItems.isEmpty) return;

    try {
      await _firestoreService.processRefund(
        products: _refundItems,
        agentId: agentId,
        locationId: locationId,
      );
      clearRefund();
    } catch (e) {
      rethrow;
    }
  }
}

viewmodels\sales_vm.dart:

# viewmodels\sales_vm.dart
import 'package:flutter/material.dart';
import 'package:salesgo/models/discount.dart';
import 'package:salesgo/models/product.dart';
import 'package:salesgo/models/sale.dart';
import 'package:salesgo/models/cart_item.dart';
import 'package:salesgo/services/firestore_service.dart';
import 'package:uuid/uuid.dart';

class SalesViewModel with ChangeNotifier {
  final List<CartItem> _cartItems = [];
  final FirestoreService _firestoreService;
  final Uuid _uuid = const Uuid();

  SalesViewModel({required FirestoreService firestoreService})
      : _firestoreService = firestoreService;

  // 🔒 Accès externe en lecture seule
  List<CartItem> get cartItems => List.unmodifiable(_cartItems);

  // 💲 Total des prix avec remises appliquées
  double get totalAmount => _calculateTotal();

  // ➕ Ajouter une ligne produit unique au panier
  void addToCart(Product product) {
    final cartItem = CartItem(
      id: _uuid.v4(),
      product: product,
    );
    _cartItems.add(cartItem);
    notifyListeners();
  }

  // ➖ Supprimer une ligne du panier
  void removeFromCart(int index) {
    if (index >= 0 && index < _cartItems.length) {
      _cartItems.removeAt(index);
      notifyListeners();
    }
  }

  // 🎯 Appliquer une remise à une ligne spécifique
  void selectDiscountForCartItem(String cartItemId, Discount? discount) {
    try {
      final cartItem = _cartItems.firstWhere((item) => item.id == cartItemId);
      cartItem.discount = discount;
      notifyListeners();
    } catch (_) {
      // CartItem introuvable : rien à faire
    }
  }

  // 📌 Obtenir la remise d'une ligne spécifique
  Discount? getSelectedDiscountForCartItem(String cartItemId) {
    try {
      return _cartItems.firstWhere((item) => item.id == cartItemId).discount;
    } catch (_) {
      return null;
    }
  }

  // 💾 Confirmer la vente et enregistrer dans Firestore
  Future<void> confirmSale({
    required String paymentMethod,
    required String agentId,
    required String locationId,
    String? couponCode,
  }) async {
    if (_cartItems.isEmpty) {
      throw Exception('Cannot confirm sale with an empty cart.');
    }

    try {
      final discountedProducts = _cartItems.map((item) {
        final discount = item.discount;
        final finalPrice = discount != null
            ? _calculatePriceWithDiscount(item.product.price, discount)
            : item.product.price;

        return Product(
          id: item.product.id,
          name: item.product.name,
          price: finalPrice,
          categoryRef: item.product.categoryRef,
          barcode: item.product.barcode,
          imageUrl: item.product.imageUrl,
          //createdAt: item.product.createdAt,

        );
      }).toList();

      final total = discountedProducts.fold(
        0.0,
        (sum, product) => sum + (product.price ?? 0),
      );

      final sale = Sale(
        id: _uuid.v4(),
        agentId: agentId,
        locationId: locationId,
        date: DateTime.now(),
        products: discountedProducts,
        totalAmount: total,
        paymentMethod: paymentMethod,
        couponCode: couponCode,
      );

      await _firestoreService.recordSale(sale);
      clearCart();
    } catch (e) {
      debugPrint('Error confirming sale: $e');
      rethrow;
    }
  }

  // 🧹 Vider le panier
  void clearCart() {
    _cartItems.clear();
    notifyListeners();
  }

  // 🧮 Calcul du total avec remises
  double _calculateTotal() {
    return _cartItems.fold(0.0, (sum, item) {
      final discount = item.discount;
      final basePrice = item.product.price;
      final price = discount != null
          ? _calculatePriceWithDiscount(basePrice, discount)
          : basePrice;
      return sum + (price ?? 0);
    });
  }

  // 📉 Appliquer une remise à un prix
  double _calculatePriceWithDiscount(double basePrice, Discount discount) {
    return discount.type == '%'
        ? basePrice * (1 - discount.value / 100)
        : basePrice - discount.value;
  }
}


viewmodels\stock_vm.dart:

# viewmodels\stock_vm.dart
import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import '../services/firestore_service.dart';

class StockViewModel with ChangeNotifier {
  final FirestoreService _firestoreService;
  Map<String, int> _stock = {};
  Map<String, int> _monthlySales = {};
  bool _isLoading = false;
  StreamSubscription<Map<String, int>>? _salesSubscription;

  StockViewModel({required FirestoreService firestoreService})
      : _firestoreService = firestoreService;

  Map<String, int> get stock => _stock;
  Map<String, int> get monthlySales => _monthlySales;
  bool get isLoading => _isLoading;

  Map<String, int> get adjustedStock {
    final adjusted = <String, int>{};
    _stock.forEach((productId, quantity) {
      adjusted[productId] = quantity - (_monthlySales[productId] ?? 0);
    });
    return adjusted;
  }

  Future<void> loadStock(String locationId) async {
    _salesSubscription?.cancel();

    _isLoading = true;
    notifyListeners();

    try {
      // 🔥 Load assigned stock from stockHistory
      final assignedStock = await _loadAssignedStockFromHistory(locationId);
      _stock = assignedStock;

      _loadMonthlySales(locationId);
    } catch (error) {
      _isLoading = false;
      notifyListeners();
      debugPrint('Error loading stock: $error');
    }
  }

  Future<Map<String, int>> _loadAssignedStockFromHistory(String locationId) async {
    final snapshot = await FirebaseFirestore.instance
        .collection('stockHistory')
        .where('locationId', isEqualTo: locationId)
        .get();

    final Map<String, int> assignedStock = {};
    for (final doc in snapshot.docs) {
      final data = doc.data();
      final productId = data['productId'] as String;
      final quantity = data['quantity'] as int;

      assignedStock[productId] = (assignedStock[productId] ?? 0) + quantity;
    }
    return assignedStock;
  }

  void _loadMonthlySales(String locationId) {
    final now = DateTime.now();
    final firstDayOfMonth = DateTime(now.year, now.month, 1);

    _salesSubscription = _firestoreService
        .getMonthlySales(locationId, firstDayOfMonth)
        .listen((salesData) {
      _monthlySales = salesData;
      _isLoading = false;
      notifyListeners();
    }, onError: (error) {
      _isLoading = false;
      notifyListeners();
      debugPrint('Error loading monthly sales: $error');
    });
  }

  @override
  void dispose() {
    _salesSubscription?.cancel();
    super.dispose();
  }
}


views\login_screen.dart:

# views\login_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../viewmodels/auth_vm.dart';

class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key});

  @override
  _LoginScreenState createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();

  @override
  Widget build(BuildContext context) {
    final authVM = Provider.of<AuthViewModel>(context);

    return Scaffold(
      appBar: AppBar(title: const Text('Login')),
      body: Container(
        decoration: const BoxDecoration(
          image: DecorationImage(
            image: AssetImage('assets/images/login.PNG'), // Updated to AssetImage
            fit: BoxFit.cover,
          ),
        ),
        child: Center(
          child: Container(
            padding: const EdgeInsets.all(16.0),
            margin: const EdgeInsets.all(24.0),
            decoration: BoxDecoration(
              color: Colors.white.withOpacity(0.85),
              borderRadius: BorderRadius.circular(16.0),
            ),
            child: SingleChildScrollView(
              child: Form(
                key: _formKey,
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: <Widget>[
                    const SizedBox(height: 20),
                    const Icon(Icons.lock_person, size: 80, color: Colors.blue),
                    const SizedBox(height: 30),
                    TextFormField(
                      controller: _emailController,
                      decoration: const InputDecoration(
                        labelText: 'Email',
                        prefixIcon: Icon(Icons.email),
                        border: OutlineInputBorder(),
                      ),
                      keyboardType: TextInputType.emailAddress,
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please enter your email';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),
                    TextFormField(
                      controller: _passwordController,
                      decoration: const InputDecoration(
                        labelText: 'Password',
                        prefixIcon: Icon(Icons.lock),
                        border: OutlineInputBorder(),
                      ),
                      obscureText: true,
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please enter your password';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 24),
                    SizedBox(
                      width: double.infinity,
                      child: ElevatedButton(
                        onPressed: () async {
                          if (_formKey.currentState!.validate()) {
                            try {
                              await authVM.signIn(_emailController.text, _passwordController.text);
                            } catch (e) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                SnackBar(content: Text('Login failed: $e')),
                              );
                            }
                          }
                        },
                        child: const Text('Login'),
                      ),
                    ),
                    const SizedBox(height: 16),
                    TextButton(
                      onPressed: () {
                        Navigator.pushNamed(context, '/signup');
                      },
                      style: TextButton.styleFrom(
                        foregroundColor: Theme.of(context).primaryColor,
                      ),
                      child: const Text("Don't have an account? Sign up"),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

views\signup_screen.dart:

# views\signup_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../viewmodels/auth_vm.dart';

class SignupScreen extends StatefulWidget {
  const SignupScreen({super.key});

  @override
  _SignupScreenState createState() => _SignupScreenState();
}

class _SignupScreenState extends State<SignupScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _nameController = TextEditingController();
  String _selectedRole = 'agent';

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Create Account')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: ListView(
            children: [
              TextFormField(
                controller: _nameController,
                decoration: const InputDecoration(labelText: 'Full Name'),
                validator: (value) => value!.isEmpty ? 'Required' : null,
              ),
              TextFormField(
                controller: _emailController,
                decoration: const InputDecoration(labelText: 'Email'),
                validator: (value) => 
                    value!.isEmpty ? 'Required' : 
                    !value.contains('@') ? 'Invalid email' : null,
              ),
              TextFormField(
                controller: _passwordController,
                decoration: const InputDecoration(labelText: 'Password'),
                obscureText: true,
                validator: (value) => value!.length < 6 
                    ? 'Minimum 6 characters' 
                    : null,
              ),
              DropdownButtonFormField<String>(
                value: _selectedRole,
                items: const [
                  DropdownMenuItem(value: 'agent', child: Text('Agent')),
                  DropdownMenuItem(value: 'admin', child: Text('Admin')),
                ],
                onChanged: (value) => setState(() => _selectedRole = value!),
                decoration: const InputDecoration(labelText: 'Role'),
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: _signUp,
                child: const Text('Sign Up'),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _signUp() async {
    if (_formKey.currentState!.validate()) {
      try {
        final authVM = Provider.of<AuthViewModel>(context, listen: false);
        await authVM.signUp(
          _emailController.text,
          _passwordController.text,
          _nameController.text,
          _selectedRole,
        );
        
        if (authVM.currentUser != null) {
          Navigator.pushReplacementNamed(context, '/');
        }
      } catch (e) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Signup failed: ${e.toString()}')),
        );
      }
    }
  }
}

views\admin\admin_home_screen.dart:

# views\admin\admin_home_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:salesgo/views/admin/location_management.dart';
import 'package:salesgo/views/admin/product_management.dart';
import 'users_management.dart';
import 'stock_management.dart';
import 'reports_screen.dart';
import '../../viewmodels/auth_vm.dart';

class AdminHomeScreen extends StatefulWidget {
  const AdminHomeScreen({super.key});

  @override
  State<AdminHomeScreen> createState() => _AdminHomeScreenState();
}

class _AdminHomeScreenState extends State<AdminHomeScreen> {
  int _selectedIndex = 0;

  static const List<Widget> _adminScreens = [
    UsersScreen(),
    ProductManagement(),
    LocationManagement(),
    StockManagement(),
    ReportsScreen(),
  ];

  void _onItemTapped(int index) {
    setState(() => _selectedIndex = index);
  }

  void _logout(BuildContext context) async {
    final authVM = Provider.of<AuthViewModel>(context, listen: false);
    await authVM.signOut();
    Navigator.pushReplacementNamed(context, '/');
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Admin Dashboard'),
        actions: [
          IconButton(
            icon: const Icon(Icons.logout),
            onPressed: () => _logout(context),
          ),
        ],
      ),
      body: _adminScreens.elementAt(_selectedIndex),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _selectedIndex,
        onTap: _onItemTapped,
        type: BottomNavigationBarType.fixed, // Important for more than 3 items
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.people),
            label: 'Agents',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.shopping_bag),
            label: 'Products',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.map),
            label: 'Locations',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.warehouse_outlined),
            label: 'Stock',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.analytics),
            label: 'Rapports',
          ),
        ],
        selectedItemColor: Colors.blue, // Customize as needed
        unselectedItemColor: Colors.grey, // Customize as needed
      ),
    );
  }
}

views\admin\location_management.dart:

# views\admin\location_management.dart
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:salesgo/models/location.dart';
import 'package:salesgo/models/user.dart';

class LocationManagement extends StatefulWidget {
  const LocationManagement({super.key});

  @override
  _LocationManagementState createState() => _LocationManagementState();
}

class _LocationManagementState extends State<LocationManagement> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  String _selectedType = 'van';
  String? _selectedAgentId;

  Future<void> _addLocation() async {
    if (_formKey.currentState!.validate()) {
      try {
        final location = Location(
          id: FirebaseFirestore.instance.collection('locations').doc().id,
          name: _nameController.text,
          type: _selectedType,
          assignedAgentId: _selectedAgentId,
          createdAt: DateTime.now(),
        );

        // Create a batch to update both documents atomically
        final batch = FirebaseFirestore.instance.batch();
        
        // 1. Set the location document
        final locationRef = FirebaseFirestore.instance
            .collection('locations')
            .doc(location.id);
        batch.set(locationRef, location.toMap());
        
        // 2. If an agent is assigned, update the user document
        if (_selectedAgentId != null) {
          final userRef = FirebaseFirestore.instance
              .collection('users')
              .doc(_selectedAgentId);
          batch.update(userRef, {'assignedLocationId': location.id});
        }

        // Commit both operations together
        await batch.commit();

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Location added successfully')),
        );

        // Clear form
        _formKey.currentState!.reset();
        setState(() => _selectedAgentId = null);
      } catch (e) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error adding location: $e')),
        );
      }
    }
  
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Location Management')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: ListView(
            children: [
              TextFormField(
                controller: _nameController,
                decoration: const InputDecoration(labelText: 'Location Name'),
                validator: (value) => value!.isEmpty ? 'Required' : null,
              ),
              const SizedBox(height: 20),
              DropdownButtonFormField<String>(
                value: _selectedType,
                items: const [
                  DropdownMenuItem(value: 'warehouse', child: Text('Warehouse')),
                  DropdownMenuItem(value: 'store', child: Text('Store')),
                  DropdownMenuItem(value: 'van', child: Text('Mobile Van')),
                ],
                onChanged: (value) => setState(() => _selectedType = value!),
                decoration: const InputDecoration(labelText: 'Location Type'),
              ),
              const SizedBox(height: 20),
              const Text('Assign to Agent (optional)'),
              StreamBuilder<QuerySnapshot>(
                stream: FirebaseFirestore.instance
                    .collection('users')
                    .where('role', isEqualTo: 'agent')
                    .snapshots(),
                builder: (context, snapshot) {
                  if (!snapshot.hasData) {
                    return const CircularProgressIndicator();
                  }
                  final agents = snapshot.data!.docs
                      .map((doc) => AppUser.fromFirestore(doc.data() as Map<String, dynamic>))
                      .toList();
                  
                  return DropdownButton<String>(
                    value: _selectedAgentId,
                    hint: const Text('Select Agent'),
                    items: agents.map((agent) {
                      return DropdownMenuItem<String>(
                        value: agent.uid,
                        child: Text(agent.email),
                      );
                    }).toList(),
                    onChanged: (value) => setState(() => _selectedAgentId = value),
                  );
                },
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: _addLocation,
                child: const Text('Add Location'),
              ),
              const SizedBox(height: 20),
              const Divider(),
              const Text('Existing Locations', style: TextStyle(fontSize: 18)),
              const SizedBox(height: 10),
              StreamBuilder<QuerySnapshot>(
                stream: FirebaseFirestore.instance.collection('locations').snapshots(),
                builder: (context, snapshot) {
                  if (!snapshot.hasData) {
                    return const CircularProgressIndicator();
                  }
                  return ListView.builder(
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    itemCount: snapshot.data!.docs.length,
                    itemBuilder: (context, index) {
                      final doc = snapshot.data!.docs[index];
                      final location = Location.fromFirestore(doc.data() as Map<String, dynamic>);
                      return ListTile(
                        title: Text(location.name),
                        subtitle: Text('Type: ${location.type}'),
                        trailing: IconButton(
                          icon: const Icon(Icons.delete),
                          onPressed: () => _deleteLocation(doc.id),
                        ),
                      );
                    },
                  );
                },
              ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _deleteLocation(String locationId) async {
    try {
      await FirebaseFirestore.instance.collection('locations').doc(locationId).delete();
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Location deleted')),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error deleting location: $e')),
      );
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    super.dispose();
  }
}

views\admin\product_management.dart:

# views\admin\product_management.dart
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:image_picker/image_picker.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:intl/intl.dart';
import 'package:salesgo/models/product.dart';
import 'package:salesgo/models/discount.dart';
import 'package:mobile_scanner/mobile_scanner.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:salesgo/services/firestore_service.dart';

class ProductManagement extends StatefulWidget {
  const ProductManagement({super.key});

  @override
  _ProductManagementState createState() => _ProductManagementState();
}

class _ProductManagementState extends State<ProductManagement> with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _priceController = TextEditingController();
  String? _selectedProductCategory;
  final _barcodeController = TextEditingController();
  String? _imageUrl;
  bool _isLoading = false;
  bool _hasDateRange = false; // New flag for date range toggle

  // For categories
  final _categoryNameController = TextEditingController();

  // For discounts
  final _discountNameController = TextEditingController();
  final _discountValueController = TextEditingController();
  final _discountTypeController = TextEditingController();
  String? _selectedDiscountCategory;
  DateTime? _discountStartDate;
  DateTime? _discountEndDate;

  final FirestoreService _firestoreService = FirestoreService();



  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    _nameController.dispose();
    _priceController.dispose();
    _barcodeController.dispose();
    _categoryNameController.dispose();
    _discountNameController.dispose();
    _discountValueController.dispose();
    _discountTypeController.dispose();
    _scannerController.dispose();

    super.dispose();
  }

  // Add to your state class
  final MobileScannerController _scannerController = MobileScannerController();

  Future<void> _scanBarcode() async {
    try {
      final status = await Permission.camera.request();
      if (!status.isGranted) {
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Camera permission is required')),
        );
        return;
      }

      if (!mounted) return;
      final barcode = await showDialog<String>(
        context: context,
        builder: (context) => Dialog(
          child: ConstrainedBox(
            constraints: BoxConstraints(
              maxWidth: MediaQuery.of(context).size.width * 0.8,
              maxHeight: MediaQuery.of(context).size.height * 0.6,
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Text('Scan Barcode', style: Theme.of(context).textTheme.titleLarge),
                ),
                Expanded(
                  child: ClipRRect(
                    borderRadius: BorderRadius.circular(8),
                    child: MobileScanner(
                      controller: _scannerController,
                      onDetect: (capture) {
                        final barcodes = capture.barcodes;
                        if (barcodes.isNotEmpty) {
                          Navigator.pop(context, barcodes.first.rawValue);
                        }
                      },
                    ),
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Text('Point the camera at a barcode',
                    style: TextStyle(color: Colors.grey[600])),
                ),
                TextButton(
                  onPressed: () {
                    _scannerController.stop();
                    Navigator.pop(context);
                  },
                  child: const Text('Cancel'),
                ),
              ],
            ),
          ),
        ),
      );

      if (barcode != null && barcode.isNotEmpty && mounted) {
        setState(() {
          _barcodeController.text = barcode;
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error scanning barcode: ${e.toString()}')),
        );
      }
    } finally {
      _scannerController.stop();
    }
  }

  Future<void> _pickImage() async {
    final picker = ImagePicker();
    final pickedFile = await picker.pickImage(source: ImageSource.gallery);

    if (pickedFile != null) {
      setState(() => _isLoading = true);
      try {
        final ref = FirebaseStorage.instance
            .ref()
            .child('product_images/${DateTime.now().millisecondsSinceEpoch}');
        
        await ref.putFile(File(pickedFile.path));
        _imageUrl = await ref.getDownloadURL();
      } catch (e) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to upload image: $e')),
        );
      } finally {
        setState(() => _isLoading = false);
      }
    }
  }

  Future<void> _addProduct() async {
    if (!_formKey.currentState!.validate()) return;
    
    setState(() => _isLoading = true);
    try {
      await _firestoreService.addProduct(
        name: _nameController.text,
        price: double.parse(_priceController.text),
        categoryId: _selectedProductCategory!,
        barcode: _barcodeController.text,
        imageUrl: _imageUrl,
      );

      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Product added successfully')),
      );
      _resetForm();
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error: ${e.toString()}')),
      );
    } finally {
      setState(() => _isLoading = false);
    }
  }

  Future<void> _updateProduct(String productId) async {
    if (!_formKey.currentState!.validate()) return;
    
    setState(() => _isLoading = true);
    try {
      await _firestoreService.updateProduct(
        productId: productId,
        name: _nameController.text,
        price: double.parse(_priceController.text),
        categoryId: _selectedProductCategory!,
        barcode: _barcodeController.text,
        imageUrl: _imageUrl,
      );

      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Product updated successfully')),
      );
      Navigator.pop(context);
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error: ${e.toString()}')),
      );
    } finally {
      setState(() => _isLoading = false);
    }
  }

  void _resetForm() {
    _formKey.currentState?.reset();
    setState(() {
      _imageUrl = null;
      _selectedProductCategory = null;
      _barcodeController.clear();
    });
  }

  Future<void> _addCategory() async {
    if (_categoryNameController.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Category name is required')),
      );
      return;
    }

    setState(() => _isLoading = true);
    try {
      await FirebaseFirestore.instance.collection('categories').add({
        'name': _categoryNameController.text,
        'createdAt': FieldValue.serverTimestamp(),
      });

      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Category added successfully')),
      );

      // Clear form
      _categoryNameController.clear();
      Navigator.pop(context);
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error adding category: $e')),
      );
    } finally {
      setState(() => _isLoading = false);
    }
  }

  Future<void> _updateCategory(String categoryId) async {
    if (_categoryNameController.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Category name is required')),
      );
      return;
    }

    setState(() => _isLoading = true);
    try {
      final categoryRef = FirebaseFirestore.instance.collection('categories').doc(categoryId);
      final oldName = (await categoryRef.get()).data()?['name'];
      final newName = _categoryNameController.text;

      // 1. First update the category name
      await categoryRef.update({'name': newName});

      // 2. Update all products in this category
      final productsQuery = await FirebaseFirestore.instance
          .collection('products')
          .where('categoryId', isEqualTo: oldName)
          .get();

      final batch = FirebaseFirestore.instance.batch();
      for (final doc in productsQuery.docs) {
        batch.update(doc.reference, {'categoryId': newName});
      }

      // 3. Update all discounts for this category
      final discountsQuery = await FirebaseFirestore.instance
          .collection('discounts')
          .where('categoryId', isEqualTo: oldName)
          .get();

      for (final doc in discountsQuery.docs) {
        batch.update(doc.reference, {'categoryId': newName});
      }

      // Commit all updates in a single batch
      await batch.commit();

      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Category and related items updated successfully')),
      );
      Navigator.pop(context);
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error updating category: $e')),
      );
    } finally {
      setState(() => _isLoading = false);
    }
  }

  Future<void> _addDiscount() async {
    if (_discountNameController.text.isEmpty ||
        _discountValueController.text.isEmpty ||
        _discountTypeController.text.isEmpty ||
        _selectedDiscountCategory == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Required fields are missing')),
      );
      return;
    }

    // Only validate dates if the user has enabled date range
    if (_hasDateRange) {
      if (_discountStartDate == null || _discountEndDate == null) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Date range is enabled but not set')),
        );
        return;
      }

      if (_discountEndDate!.isBefore(_discountStartDate!)) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('End date must be after start date')),
        );
        return;
      }
    }

    setState(() => _isLoading = true);
    try {
      final categoryRef = FirebaseFirestore.instance
          .collection('categories')
          .doc(_selectedDiscountCategory);

      final discountData = {
        'id': FirebaseFirestore.instance.collection('discounts').doc().id,
        'name': _discountNameController.text,
        'categoryRef': categoryRef,  // Store DocumentReference
        'value': double.parse(_discountValueController.text),
        'type': _discountTypeController.text,
        'hasDateRange': _hasDateRange,
        if (_hasDateRange) 'startDate': _discountStartDate!,
        if (_hasDateRange) 'endDate': _discountEndDate!,
      };

      await FirebaseFirestore.instance
          .collection('discounts')
          .doc(discountData['id'] as String?)
          .set(discountData);

      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Discount added successfully')),
      );

      // Clear form
      _discountNameController.clear();
      _discountValueController.clear();
      _discountTypeController.clear();
      setState(() {
        _selectedDiscountCategory = null;
        _discountStartDate = null;
        _discountEndDate = null;
        _hasDateRange = false;
      });
      Navigator.pop(context);
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error adding discount: $e')),
      );
    } finally {
      setState(() => _isLoading = false);
    }
  }

  Future<void> _updateDiscount(String discountId) async {
    if (_discountNameController.text.isEmpty ||
        _discountValueController.text.isEmpty ||
        _discountTypeController.text.isEmpty ||
        _selectedDiscountCategory == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Required fields are missing')),
      );
      return;
    }

    // Only validate dates if date range is enabled
    if (_hasDateRange) {
      if (_discountStartDate == null || _discountEndDate == null) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Date range is enabled but dates are not set')),
        );
        return;
      }
      if (_discountEndDate!.isBefore(_discountStartDate!)) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('End date must be after start date')),
        );
        return;
      }
    }

    setState(() => _isLoading = true);
    try {
      final categoryRef = FirebaseFirestore.instance
          .collection('categories')
          .doc(_selectedDiscountCategory);

      final updateData = {
        'name': _discountNameController.text,
        'categoryRef': categoryRef,  // Store DocumentReference
        'value': double.parse(_discountValueController.text),
        'type': _discountTypeController.text,
        'hasDateRange': _hasDateRange,
      };

      // Conditionally update dates
      if (_hasDateRange) {
        updateData['startDate'] = _discountStartDate!;
        updateData['endDate'] = _discountEndDate!;
      } else {
        // Remove dates if date range is disabled
        updateData['startDate'] = FieldValue.delete();
        updateData['endDate'] = FieldValue.delete();
      }

      await FirebaseFirestore.instance
          .collection('discounts')
          .doc(discountId)
          .update(updateData);

      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Discount updated successfully')),
      );
      Navigator.pop(context);
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error updating discount: $e')),
      );
    } finally {
      setState(() => _isLoading = false);
    }
  }
  // Update the _editDiscount method to handle the new hasDateRange field
  Future<void> _editDiscount(DocumentSnapshot discount) async {
    final data = discount.data() as Map<String, dynamic>;
    _discountNameController.text = data['name'] ?? '';
    _discountValueController.text = data['value'].toString();
    _discountTypeController.text = data['type'];
    // Get the category ID from the DocumentReference
    final categoryRef = data['categoryRef'] as DocumentReference;
    final categorySnapshot = await categoryRef.get();
    _selectedDiscountCategory = categorySnapshot.id;    

    setState(() {
      _hasDateRange = data['hasDateRange'] ?? false;
      if (_hasDateRange) {
        _discountStartDate = (data['startDate'] as Timestamp).toDate();
        _discountEndDate = (data['endDate'] as Timestamp).toDate();
      } else {
        _discountStartDate = null;
        _discountEndDate = null;
      }
    });

    await showDialog(
      context: context,
      builder: (context) => _buildDiscountForm(isEditing: true, discountId: discount.id),
    );
  }

  Future<void> _deleteProduct(String productId) async {
    try {
      await FirebaseFirestore.instance
          .collection('products')
          .doc(productId)
          .delete();
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Product deleted')),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error deleting product: $e')),
      );
    }
  }

  Future<void> _deleteCategory(String categoryId) async {
    try {
      await FirebaseFirestore.instance
          .collection('categories')
          .doc(categoryId)
          .delete();
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Category deleted')),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error deleting category: $e')),
      );
    }
  }

  Future<void> _deleteDiscount(String discountId) async {
    try {
      await FirebaseFirestore.instance
          .collection('discounts')
          .doc(discountId)
          .delete();
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Discount deleted successfully')),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error deleting discount: ${e.toString()}')),
      );
    }
  }

  Future<void> _selectStartDate(BuildContext context) async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: DateTime.now(),
      firstDate: DateTime.now(),
      lastDate: DateTime(2101),
    );
    if (picked != null && picked != _discountStartDate) {
      setState(() {
        _discountStartDate = picked;
      });
    }
  }

  Future<void> _selectEndDate(BuildContext context) async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _discountStartDate ?? DateTime.now(),
      firstDate: _discountStartDate ?? DateTime.now(),
      lastDate: DateTime(2101),
    );
    if (picked != null && picked != _discountEndDate) {
      setState(() {
        _discountEndDate = picked;
      });
    }
  }

  Future<void> _editProduct(Product product) async {
    _nameController.text = product.name;
    _priceController.text = product.price.toString();
    
    // Get the category ID from the DocumentReference
    final categorySnapshot = await product.categoryRef.get();
    _selectedProductCategory = categorySnapshot.id;
    
    _barcodeController.text = product.barcode;
    setState(() => _imageUrl = product.imageUrl);

    await showDialog(
      context: context,
      builder: (context) => _buildProductForm(isEditing: true, productId: product.id),
    );
  }

  Future<void> _editCategory(DocumentSnapshot category) async {
    _categoryNameController.text = category['name'];

    await showDialog(
      context: context,
      builder: (context) => _buildCategoryForm(isEditing: true, categoryId: category.id),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Product Management'),
        bottom: TabBar(
          controller: _tabController,
          tabs: const [
            Tab(icon: Icon(Icons.shopping_bag), text: 'Products'),
            Tab(icon: Icon(Icons.category), text: 'Categories'),
            Tab(icon: Icon(Icons.discount), text: 'Discounts'),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          // Products Tab
          _buildProductsTab(),
          // Categories Tab
          _buildCategoriesTab(),
          // Discount & Loyalty Tab
          _buildDiscountsTab(),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          switch (_tabController.index) {
            case 0: // Products tab
              _nameController.clear();
              _priceController.clear();
              _barcodeController.clear();
              setState(() {
                _imageUrl = null;
                _selectedProductCategory = null;
              });
              showDialog(
                context: context,
                builder: (context) => _buildProductForm(),
              );
              break;
            case 1: // Categories tab
              _categoryNameController.clear();
              //setState(() => _categoryImageUrl = null);
              showDialog(
                context: context,
                builder: (context) => _buildCategoryForm(),
              );
              break;
            case 2: // Discounts tab
              _discountNameController.clear();
              _discountValueController.clear();
              _discountTypeController.clear();
              setState(() {
                _selectedDiscountCategory = null;
                _discountStartDate = null;
                _discountEndDate = null;
              });
              showDialog(
                context: context,
                builder: (context) => _buildDiscountForm(),
              );
              break;
          }
        },
        child: const Icon(Icons.add),
      ),
    );
  }

  Widget _buildProductListTile(Product product, String docId) {
    return FutureBuilder<DocumentSnapshot>(
      future: product.categoryRef.get(),
      builder: (context, categorySnapshot) {
        if (!categorySnapshot.hasData) {
          return ListTile(
            leading: product.imageUrl != null 
                ? Image.network(product.imageUrl!, width: 50, height: 50)
                : const Icon(Icons.shopping_bag),
            title: Text(product.name),
            subtitle: Text('€${product.price} - Loading category...'),
          );
        }

        final categoryDoc = categorySnapshot.data!;
        final categoryName = categoryDoc.exists ? categoryDoc['name'] ?? 'Unknown' : 'Unknown';

        return ListTile(
          leading: product.imageUrl != null 
              ? Image.network(product.imageUrl!, width: 50, height: 50)
              : const Icon(Icons.shopping_bag),
          title: Text(product.name),
          subtitle: Text('€${product.price} - $categoryName'),
          trailing: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              IconButton(
                icon: const Icon(Icons.edit),
                onPressed: () => _editProduct(product),
              ),
              IconButton(
                icon: const Icon(Icons.delete),
                onPressed: () => _deleteProduct(docId),
              ),
            ],
          ),
        );
      },
    );
  }


  Widget _buildProductsTab() {
    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: StreamBuilder<QuerySnapshot>(
        stream: FirebaseFirestore.instance.collection('products').snapshots(),
        builder: (context, snapshot) {
          if (!snapshot.hasData) {
            return const Center(child: CircularProgressIndicator());
          }
          return ListView.builder(
            itemCount: snapshot.data!.docs.length,
            itemBuilder: (context, index) {
              final doc = snapshot.data!.docs[index];
              final product = Product.fromFirestore(doc);
              return _buildProductListTile(product, doc.id);
            },
          );
        },
      ),
    );
  }

  Widget _buildCategoriesTab() {
    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: StreamBuilder<QuerySnapshot>(
        stream: FirebaseFirestore.instance.collection('categories').snapshots(),
        builder: (context, snapshot) {
          if (!snapshot.hasData) {
            return const Center(child: CircularProgressIndicator());
          }
          return ListView.builder(
            itemCount: snapshot.data!.docs.length,
            itemBuilder: (context, index) {
              final doc = snapshot.data!.docs[index];
              return ListTile(
                leading: const Icon(Icons.category),
                title: Text(doc['name']),
                trailing: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    IconButton(
                      icon: const Icon(Icons.edit),
                      onPressed: () => _editCategory(doc),
                    ),
                    IconButton(
                      icon: const Icon(Icons.delete),
                      onPressed: () => _deleteCategory(doc.id),
                    ),
                  ],
                ),
              );
            },
          );
        },
      ),
    );
  }

  // Update the _buildDiscountsTab method to show date range info
  Widget _buildDiscountsTab() {
    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: StreamBuilder<QuerySnapshot>(
        stream: FirebaseFirestore.instance.collection('discounts').snapshots(),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
            return const Center(
              child: Text(
                'No discounts available',
                style: TextStyle(fontSize: 16),
              ),
            );
          }

          return ListView.builder(
            itemCount: snapshot.data!.docs.length,
            itemBuilder: (context, index) {
              final doc = snapshot.data!.docs[index];
              final discount = Discount.fromFirestore(doc);

              return FutureBuilder<DocumentSnapshot>(
                future: discount.categoryRef.get(),
                builder: (context, categorySnapshot) {
                  final categoryDoc = categorySnapshot.data;
                  final categoryName = categoryDoc != null && categoryDoc.exists
                      ? categoryDoc.get('name') ?? 'Unknown Category'
                      : 'Unknown Category';
                  return Card(
                    margin: const EdgeInsets.symmetric(vertical: 8),
                    child: ListTile(
                      leading: const Icon(Icons.discount, color: Colors.orange),
                      title: Text(discount.name),
                      subtitle: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text('Category: $categoryName'),
                          Text(
                            '${discount.value}${discount.type} discount',
                            style: const TextStyle(fontWeight: FontWeight.bold),
                          ),
                          const SizedBox(height: 4),
                          if (discount.hasDateRange && discount.startDate != null && discount.endDate != null) ...[
                            Text(
                              'Valid: ${DateFormat('MMM dd, yyyy').format(discount.startDate!)} - '
                              '${DateFormat('MMM dd, yyyy').format(discount.endDate!)}',
                            ),
                            const SizedBox(height: 4),
                            discount.isActive
                                ? Chip(
                                    label: const Text('Active'),
                                    backgroundColor: Colors.green[100],
                                  )
                                : Chip(
                                    label: const Text('Expired'),
                                    backgroundColor: Colors.red[100],
                                  ),
                          ] else ...[
                            Chip(
                              label: const Text('Always Active'),
                              backgroundColor: Colors.blue[100],
                            ),
                          ],
                        ],
                      ),
                      trailing: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          IconButton(
                            icon: const Icon(Icons.edit),
                            onPressed: () => _editDiscount(doc),
                          ),
                          IconButton(
                            icon: const Icon(Icons.delete, color: Colors.red),
                            onPressed: () => _deleteDiscount(doc.id),
                          ),
                        ],
                      ),
                    ),
                  );
                },
              );
            },
          );
        },
      ),
    );
  }

  String _formatDate(DateTime date) {
    return '${date.day}/${date.month}/${date.year}';
  }

  Widget _buildProductForm({bool isEditing = false, String? productId}) {
    return AlertDialog(
      title: Text(isEditing ? 'Edit Product' : 'Add New Product'),
      content: SingleChildScrollView(
        child: Form(
          key: _formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextFormField(
                controller: _nameController,
                decoration: const InputDecoration(labelText: 'Product Name'),
                validator: (value) => value!.isEmpty ? 'Required' : null,
              ),
              TextFormField(
                controller: _priceController,
                decoration: const InputDecoration(labelText: 'Price'),
                keyboardType: TextInputType.number,
                validator: (value) => value!.isEmpty ? 'Required' : null,
              ),
              StreamBuilder<QuerySnapshot>(
                stream: FirebaseFirestore.instance.collection('categories').snapshots(),
                builder: (context, snapshot) {
                  if (!snapshot.hasData) return const SizedBox();
                  
                  final categoryDocs = snapshot.data!.docs;

                  final categories = categoryDocs.map((doc) {
                    return DropdownMenuItem<String>(
                      value: doc.id,
                      child: Text(doc['name']),
                    );
                  }).toList();

                  final isValidValue = categoryDocs.any((doc) => doc.id == _selectedProductCategory);

                  return DropdownButtonFormField<String>(
                    value: isValidValue ? _selectedProductCategory : null,
                    decoration: const InputDecoration(labelText: 'Category'),
                    items: categories,
                    onChanged: (value) {
                      setState(() {
                        _selectedProductCategory = value;
                      });
                    },
                    validator: (value) => value == null ? 'Please select a category' : null,
                  );
                },
              ),
              TextFormField(
                controller: _barcodeController,
                decoration: InputDecoration(
                  labelText: 'Barcode',
                  suffixIcon: IconButton(
                    icon: const Icon(Icons.qr_code_scanner),
                    onPressed: _scanBarcode,
                  ),
                ),
                validator: (value) => value!.isEmpty ? 'Required' : null,
              ),
              const SizedBox(height: 20),
              _imageUrl != null
                  ? Image.network(_imageUrl!, height: 150)
                  : Container(),
              ElevatedButton(
                onPressed: _isLoading ? null : _pickImage,
                child: _isLoading 
                    ? const CircularProgressIndicator()
                    : const Text('Upload Image'),
              )
            ],
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('Cancel'),
        ),
        ElevatedButton(
          onPressed: () => isEditing 
              ? _updateProduct(productId!)
              : _addProduct(),
          child: Text(isEditing ? 'Update' : 'Add'),
        ),
      ],
    );
  }

  Widget _buildCategoryForm({bool isEditing = false, String? categoryId}) {
    return AlertDialog(
      title: Text(isEditing ? 'Edit Category' : 'Add New Category'),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextFormField(
              controller: _categoryNameController,
              decoration: const InputDecoration(labelText: 'Category Name'),
              validator: (value) => value!.isEmpty ? 'Required' : null,
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('Cancel'),
        ),
        ElevatedButton(
          onPressed: () => isEditing 
              ? _updateCategory(categoryId!)
              : _addCategory(),
          child: Text(isEditing ? 'Update' : 'Add'),
        ),
      ],
    );
  }

  // Update the _buildDiscountForm method
Widget _buildDiscountForm({bool isEditing = false, String? discountId}) {
  return StatefulBuilder(
    builder: (BuildContext context, StateSetter setDialogState) {
      return AlertDialog(
        title: Text(isEditing ? 'Edit Discount' : 'Add New Discount'),
        content: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextFormField(
                controller: _discountNameController,
                decoration: const InputDecoration(labelText: 'Discount Name'),
                validator: (value) => value!.isEmpty ? 'Required' : null,
              ),
              TextFormField(
                controller: _discountValueController,
                decoration: const InputDecoration(labelText: 'Value'),
                keyboardType: TextInputType.number,
                validator: (value) => value!.isEmpty ? 'Required' : null,
              ),
              TextFormField(
                controller: _discountTypeController,
                decoration: const InputDecoration(labelText: 'Type (e.g., %, \$)'),
                validator: (value) => value!.isEmpty ? 'Required' : null,
              ),
              StreamBuilder<QuerySnapshot>(
                stream: FirebaseFirestore.instance.collection('categories').snapshots(),
                builder: (context, snapshot) {
                  if (!snapshot.hasData) return const SizedBox();
                  
                  final categoryItems = snapshot.data!.docs.map((doc) {
                    return DropdownMenuItem<String>(
                      value: doc.id,
                      child: Text(doc['name']),
                    );
                  }).toList();

                  final isValidValue = snapshot.data!.docs.any((doc) => doc.id == _selectedDiscountCategory);

                  return DropdownButtonFormField<String>(
                    value: isValidValue ? _selectedDiscountCategory : null,
                    decoration: const InputDecoration(labelText: 'Category'),
                    items: categoryItems,
                    onChanged: (value) {
                      setDialogState(() {
                        _selectedDiscountCategory = value;
                      });
                    },
                    validator: (value) => value == null ? 'Please select a category' : null,
                  );
                },
                ),
                const SizedBox(height: 10),
                SwitchListTile(
                  title: const Text('Date Range'),
                  value: _hasDateRange,
                  onChanged: (bool value) {
                    setDialogState(() {
                      _hasDateRange = value;
                      if (!value) {
                        _discountStartDate = null;
                        _discountEndDate = null;
                      }
                    });
                  },
                ),
                if (_hasDateRange) ...[
                  const SizedBox(height: 10),
                  ListTile(
                    title: Text(
                      _discountStartDate == null 
                          ? 'Select Start Date' 
                          : 'Start: ${_formatDate(_discountStartDate!)}'
                    ),
                    trailing: const Icon(Icons.calendar_today),
                    onTap: () async {
                      final date = await showDatePicker(
                        context: context,
                        initialDate: DateTime.now(),
                        firstDate: DateTime.now(),
                        lastDate: DateTime(2101),
                      );
                      if (date != null) {
                        setDialogState(() => _discountStartDate = date);
                      }
                    },
                  ),
                  ListTile(
                    title: Text(
                      _discountEndDate == null 
                          ? 'Select End Date' 
                          : 'End: ${_formatDate(_discountEndDate!)}'
                    ),
                    trailing: const Icon(Icons.calendar_today),
                    onTap: () async {
                      final date = await showDatePicker(
                        context: context,
                        initialDate: _discountStartDate ?? DateTime.now(),
                        firstDate: _discountStartDate ?? DateTime.now(),
                        lastDate: DateTime(2101),
                      );
                      if (date != null) {
                        setDialogState(() => _discountEndDate = date);
                      }
                    },
                  ),
                ],
              ],
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: () {
                if (isEditing) {
                  _updateDiscount(discountId!);
                } else {
                  _addDiscount();
                }
              },
              child: Text(isEditing ? 'Update' : 'Add'),
            ),
          ],
        );
      },
    );
  }
}

views\admin\reports_screen copy.dart:

# views\admin\reports_screen copy.dart
import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_xlsio/xlsio.dart' as xlsio;
import 'package:path_provider/path_provider.dart';
import 'package:open_file/open_file.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'dart:io';
import 'package:permission_handler/permission_handler.dart';
import 'package:file_picker/file_picker.dart';

class ReportsScreen extends StatefulWidget {
  const ReportsScreen({super.key});

  @override
  State<ReportsScreen> createState() => _ReportsScreenState();
}

class _ReportsScreenState extends State<ReportsScreen> {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  DateTimeRange _dateRange = DateTimeRange(
    start: DateTime.now().subtract(const Duration(days: 30)),
    end: DateTime.now(),
  );
  String _groupBy = 'day';
  bool _isLoading = false;
  List<String> _allAgents = [];
  List<String> _selectedAgents = [];
  bool _selectAllAgents = true;
  Map<String, String> _agentIdToNameMap = {};
  List<BarChartGroupData> _chartData = [];

  @override
  void initState() {
    super.initState();
    _loadInitialData();
  }

  Future<void> _loadInitialData() async {
    await _fetchAgents();
    await _loadChartData();
  }

  Future<void> _fetchAgents() async {
    try {
      final snapshot = await _firestore.collection('users')
          .where('role', isEqualTo: 'agent')
          .get();
      
      setState(() {
        _agentIdToNameMap = {
          for (var doc in snapshot.docs) 
            doc.id: doc['name'] as String
        };
        _allAgents = _agentIdToNameMap.values.toList();
        _selectedAgents = List.from(_allAgents);
      });
    } catch (e) {
      _handleError('Error fetching agents: $e');
    }
  }

  Future<void> _loadChartData() async {
    if (!mounted) return;
    
    setState(() => _isLoading = true);
    try {
      final data = await _getChartData();
      setState(() => _chartData = data);
    } catch (e) {
      _handleError('Error loading chart data: $e');
      setState(() => _chartData = []);
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  Future<List<BarChartGroupData>> _getChartData() async {
    try {
      Query query = _firestore.collectionGroup('sales')
        .where('date', isGreaterThanOrEqualTo: _dateRange.start)
        .where('date', isLessThanOrEqualTo: _dateRange.end);

      if (!_selectAllAgents && _selectedAgents.isNotEmpty) {
        final agentIds = _selectedAgents.map((name) => 
          _agentIdToNameMap.keys.firstWhere((id) => _agentIdToNameMap[id] == name))
          .toList();
        query = query.where('agentId', whereIn: agentIds);
      }

      final QuerySnapshot snapshot = await query.orderBy('date').get();
      final Map<String, double> groupedData = {};

      for (final doc in snapshot.docs) {
        try {
          final date = (doc['date'] as Timestamp).toDate();
          final amount = (doc['totalAmount'] as num?)?.toDouble() ?? 0.0;
          final agentId = doc['agentId'] as String? ?? '';
          final agentName = _agentIdToNameMap[agentId] ?? 'Unknown';
          final periodKey = _getPeriodKey(date);
          final groupKey = '${periodKey}_$agentName';
          
          groupedData.update(
            groupKey,
            (value) => value + amount,
            ifAbsent: () => amount,
          );
        } catch (e) {
          debugPrint('Error processing document ${doc.id}: $e');
        }
      }

      final groupKeys = groupedData.keys.toList();
      return groupedData.entries.map((entry) {
        return BarChartGroupData(
          x: groupKeys.indexOf(entry.key),
          barRods: [
            BarChartRodData(
              toY: entry.value,
              color: Colors.blue,
              width: 16,
              borderRadius: BorderRadius.circular(4),
            ),
          ],
          showingTooltipIndicators: [0],
        );
      }).toList();
    } catch (e) {
      debugPrint('Error fetching chart data: $e');
      return [];
    }
  }

  Future<Map<String, Map<String, double>>> _getExportData() async {
    try {
      Query query = _firestore.collectionGroup('sales')
        .where('date', isGreaterThanOrEqualTo: _dateRange.start)
        .where('date', isLessThanOrEqualTo: _dateRange.end);

      if (!_selectAllAgents && _selectedAgents.isNotEmpty) {
        final agentIds = _selectedAgents.map((name) => 
          _agentIdToNameMap.keys.firstWhere((id) => _agentIdToNameMap[id] == name))
          .toList();
        query = query.where('agentId', whereIn: agentIds);
      }

      final QuerySnapshot snapshot = await query.orderBy('date').get();
      final Map<String, Map<String, double>> exportData = {};

      for (final doc in snapshot.docs) {
        final date = (doc['date'] as Timestamp).toDate();
        final amount = (doc['totalAmount'] as num).toDouble();
        final agentId = doc['agentId'] as String;
        final agentName = _agentIdToNameMap[agentId] ?? 'Unknown';
        final periodKey = _getPeriodKey(date);

        exportData.putIfAbsent(periodKey, () => {});
        exportData[periodKey]!.update(
          agentName,
          (value) => value + amount,
          ifAbsent: () => amount,
        );
      }

      return exportData;
    } catch (e) {
      debugPrint('Error fetching export data: $e');
      return {};
    }
  }

  String _getPeriodKey(DateTime date) {
    switch (_groupBy) {
      case 'day':
        return DateFormat('yyyy-MM-dd').format(date);
      case 'week':
        return 'Week ${DateFormat('w').format(date)}';
      case 'month':
        return DateFormat('yyyy-MM').format(date);
      default:
        return DateFormat('yyyy-MM-dd').format(date);
    }
  }

  Future<Directory> _getSafeDownloadDirectory() async {
    try {
      if (Platform.isAndroid) {
        // Request permission to manage external storage
        PermissionStatus permission = await Permission.manageExternalStorage.request();
        if (!permission.isGranted) {
          throw Exception('Permission denied to access storage.');
        }

        // Try to access the real Downloads folder
        final directories = await getExternalStorageDirectories(type: StorageDirectory.downloads);
        if (directories == null || directories.isEmpty) {
          throw Exception('Downloads directory not found.');
        }
        return directories.first;
      } else if (Platform.isIOS) {
        // For iOS, use the safe downloads directory
        final directory = await getDownloadsDirectory();
        if (directory == null) {
          throw Exception('Downloads directory not available on iOS.');
        }
        return directory;
      } else {
        // For other platforms, fallback to temporary directory
        return await getTemporaryDirectory();
      }
    } catch (e) {
      debugPrint('Error accessing download directory: $e');
      // If any error happens, fallback to temporary directory
      return await getTemporaryDirectory();
    }
  }


  Future<void> _exportToExcel() async {
    setState(() => _isLoading = true);
    try {
      final data = await _getExportData();
      if (data.isEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('No data to export')),
        );
        return;
      }

      final workbook = xlsio.Workbook();
      final sheet = workbook.worksheets[0];

      // Write Excel content
      sheet.getRangeByName('A1').setText('Period');
      int col = 1;
      final allAgents = _selectAllAgents ? _allAgents : _selectedAgents;
      for (final agent in allAgents) {
        sheet.getRangeByIndex(1, ++col).setText(agent);
      }
      sheet.getRangeByIndex(1, ++col).setText('Total');
      sheet.getRangeByName('A1:${_getExcelColumnName(col)}1').cellStyle.bold = true;

      int row = 2;
      data.forEach((period, agentData) {
        sheet.getRangeByIndex(row, 1).setText(period);
        double rowTotal = 0;
        col = 1;
        for (final agent in allAgents) {
          final amount = agentData[agent] ?? 0;
          sheet.getRangeByIndex(row, ++col).setNumber(amount);
          rowTotal += amount;
        }
        sheet.getRangeByIndex(row, ++col).setNumber(rowTotal);
        row++;
      });

      sheet.getRangeByIndex(row, 1).setText('TOTAL');
      col = 1;
      for (final agent in allAgents) {
        final colLetter = _getExcelColumnName(++col);
        sheet.getRangeByName('$colLetter$row').setFormula('SUM(${colLetter}2:${colLetter}${row-1})');
      }
      final totalCol = _getExcelColumnName(++col);
      sheet.getRangeByName('${totalCol}$row').setFormula('SUM(${totalCol}2:${totalCol}${row-1})');
      sheet.getRangeByName('A$row:$totalCol$row').cellStyle.bold = true;
      sheet.getRangeByName('A1:$totalCol$row').autoFitColumns();

      final bytes = workbook.saveAsStream();
      workbook.dispose();

      // Ask user to pick a folder
      String? selectedDirectory = await FilePicker.platform.getDirectoryPath();
      if (selectedDirectory == null) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('No folder selected')),
        );
        return;
      }

      final fileName = 'SalesReport_${DateFormat('yyyyMMdd_HHmmss').format(DateTime.now())}.xlsx';
      final file = File('$selectedDirectory/$fileName');
      await file.writeAsBytes(bytes);

      await OpenFile.open(file.path);

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Exported to $fileName')),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Export failed: ${e.toString()}')),
      );
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }



  String _getExcelColumnName(int column) {
    String name = '';
    while (column > 0) {
      column--;
      name = '${String.fromCharCode(65 + column % 26)}$name';
      column = column ~/ 26;
    }
    return name;
  }

  Future<void> _exportToPDF() async {
    setState(() => _isLoading = true);
    try {
      final data = await _getExportData();
      if (data.isEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('No data to export')),
        );
        return;
      }

      final pdf = pw.Document();
      final allAgents = _selectAllAgents ? _allAgents : _selectedAgents;

      pdf.addPage(
        pw.Page(
          pageFormat: PdfPageFormat.a4,
          build: (pw.Context context) {
            return pw.Column(
              children: [
                pw.Header(
                  level: 0,
                  child: pw.Text(
                    'Sales Report',
                    style: pw.TextStyle(fontSize: 24, fontWeight: pw.FontWeight.bold),
                  ),
                ),
                pw.Text(
                  'Date Range: ${DateFormat('MMM dd, yyyy').format(_dateRange.start)} - '
                  '${DateFormat('MMM dd, yyyy').format(_dateRange.end)}',
                  style: const pw.TextStyle(fontSize: 12),
                ),
                if (!_selectAllAgents)
                  pw.Text(
                    'Agents: ${_selectedAgents.join(', ')}',
                    style: const pw.TextStyle(fontSize: 12),
                  ),
                pw.SizedBox(height: 20),
                pw.Table.fromTextArray(
                  context: context,
                  headers: ['Period', ...allAgents, 'Total'],
                  data: data.entries.map((entry) {
                    final period = entry.key;
                    final agentData = entry.value;
                    final total = agentData.values.fold(0.0, (sum, amount) => sum + amount);

                    return [
                      period,
                      ...allAgents.map((agent) => agentData[agent]?.toStringAsFixed(2) ?? '0.00'),
                      total.toStringAsFixed(2)
                    ];
                  }).toList(),
                  cellStyle: const pw.TextStyle(fontSize: 10),
                  headerStyle: pw.TextStyle(fontSize: 12, fontWeight: pw.FontWeight.bold),
                ),
              ],
            );
          },
        ),
      );

      // Save the PDF file
      final directory = await _getSafeDownloadDirectory();
      final fileName = 'SalesReport_${DateFormat('yyyyMMdd_HHmmss').format(DateTime.now())}.pdf';
      final file = File('${directory.path}/$fileName');
      await file.writeAsBytes(await pdf.save());

      // Try to open the file
      final result = await OpenFile.open(file.path);

      // Notify the user
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Exported to $fileName')),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Export failed: ${e.toString()}')),
      );
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }


  Future<void> _showAgentFilterDialog() async {
    await showDialog(
      context: context,
      builder: (context) {
        return StatefulBuilder(
          builder: (context, setState) {
            return AlertDialog(
              title: const Text('Filter by Agent'),
              content: SingleChildScrollView(
                child: Column(
                  children: [
                    CheckboxListTile(
                      title: const Text('All Agents'),
                      value: _selectAllAgents,
                      onChanged: (value) {
                        setState(() {
                          _selectAllAgents = value ?? true;
                          if (_selectAllAgents) {
                            _selectedAgents = List.from(_allAgents);
                          }
                        });
                      },
                    ),
                    const Divider(),
                    ..._allAgents.map((agent) {
                      return CheckboxListTile(
                        title: Text(agent),
                        value: _selectedAgents.contains(agent),
                        onChanged: _selectAllAgents
                            ? null
                            : (value) {
                                setState(() {
                                  if (value ?? false) {
                                    _selectedAgents.add(agent);
                                  } else {
                                    _selectedAgents.remove(agent);
                                  }
                                });
                              },
                      );
                    }).toList(),
                  ],
                ),
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Text('Cancel'),
                ),
                TextButton(
                  onPressed: () {
                    Navigator.pop(context);
                    _loadChartData();
                  },
                  child: const Text('Apply'),
                ),
              ],
            );
          },
        );
      },
    );
  }

  Future<void> _selectDateRange(BuildContext context) async {
    final DateTimeRange? picked = await showDateRangePicker(
      context: context,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
      initialDateRange: _dateRange,
    );
    
    if (picked != null && picked != _dateRange) {
      setState(() => _dateRange = picked);
      await _loadChartData();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Sales Reports'),
        actions: [
          IconButton(
            icon: const Icon(Icons.filter_alt),
            onPressed: _showAgentFilterDialog,
            tooltip: 'Filter by Agent',
          ),
          IconButton(
            icon: const Icon(Icons.date_range),
            onPressed: () => _selectDateRange(context),
            tooltip: 'Select Date Range',
          ),
          PopupMenuButton<String>(
            icon: const Icon(Icons.group_work),
            onSelected: (value) {
              setState(() => _groupBy = value);
              _loadChartData();
            },
            itemBuilder: (context) => [
              const PopupMenuItem(value: 'day', child: Text('Daily')),
              const PopupMenuItem(value: 'week', child: Text('Weekly')),
              const PopupMenuItem(value: 'month', child: Text('Monthly')),
            ],
          ),
          PopupMenuButton<String>(
            icon: const Icon(Icons.download),
            onSelected: (value) {
              if (value == 'excel') _exportToExcel();
              if (value == 'pdf') _exportToPDF();
            },
            itemBuilder: (context) => [
              const PopupMenuItem(value: 'excel', child: Text('Export to Excel')),
              const PopupMenuItem(value: 'pdf', child: Text('Export to PDF')),
            ],
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _chartData.isEmpty
              ? const Center(child: Text('No sales data available'))
              : Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    children: [
                      Text(
                        'Sales Report: ${DateFormat('MMM dd, yyyy').format(_dateRange.start)} - '
                        '${DateFormat('MMM dd, yyyy').format(_dateRange.end)}',
                        style: Theme.of(context).textTheme.titleMedium,
                      ),
                      if (!_selectAllAgents)
                        Padding(
                          padding: const EdgeInsets.only(top: 8.0),
                          child: Text(
                            'Agents: ${_selectedAgents.join(', ')}',
                            style: Theme.of(context).textTheme.bodySmall,
                          ),
                        ),
                      const SizedBox(height: 16),
                      Expanded(
                        child: BarChart(
                          BarChartData(
                            alignment: BarChartAlignment.spaceAround,
                            barGroups: _chartData,
                            titlesData: FlTitlesData(
                              leftTitles: AxisTitles(
                                sideTitles: SideTitles(
                                  showTitles: true,
                                  getTitlesWidget: (value, meta) {
                                    return Text(value.toInt().toString());
                                  },
                                  reservedSize: 40,
                                ),
                              ),
                              bottomTitles: AxisTitles(
                                sideTitles: SideTitles(
                                  showTitles: true,
                                  getTitlesWidget: (value, meta) {
                                    final index = value.toInt();
                                    if (index >= 0 && index < _chartData.length) {
                                      final date = _dateRange.start.add(Duration(days: index));
                                      return Padding(
                                        padding: const EdgeInsets.only(top: 8.0),
                                        child: Text(
                                          _getPeriodKey(date),
                                          style: const TextStyle(fontSize: 10),
                                        ),
                                      );
                                    }
                                    return const Text('');
                                  },
                                  reservedSize: 32,
                                ),
                              ),
                            ),
                            gridData: FlGridData(show: true),
                            borderData: FlBorderData(show: false),
                            barTouchData: BarTouchData(
                              enabled: true,
                              touchTooltipData: BarTouchTooltipData(
                                getTooltipColor: (BarChartGroupData group) => Colors.blueGrey,
                                getTooltipItem: (group, groupIndex, rod, rodIndex) {
                                  final date = _dateRange.start.add(Duration(days: groupIndex));
                                  return BarTooltipItem(
                                    '${_getPeriodKey(date)}\n',
                                    const TextStyle(color: Colors.white),
                                    children: [
                                      TextSpan(
                                        text: '€${rod.toY.toStringAsFixed(2)}',
                                        style: const TextStyle(
                                          color: Colors.yellow,
                                          fontWeight: FontWeight.bold,
                                        ),
                                      ),
                                    ],
                                  );
                                },
                              ),
                            ),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
    );
  }
    void _handleError(String message) {
    debugPrint(message);
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(message)),
      );
    }
  }
}

views\admin\reports_screen.dart:

# views\admin\reports_screen.dart
import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_xlsio/xlsio.dart' as xlsio;
import 'package:path_provider/path_provider.dart';
import 'package:open_file/open_file.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'dart:io';
import 'package:permission_handler/permission_handler.dart';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/foundation.dart';

enum ChartType { bar, line, pie }

class SalesChartData {
  final String periodKey;
  final String agentName;
  final double amount;
  final int xIndex;

  SalesChartData({
    required this.periodKey,
    required this.agentName,
    required this.amount,
    required this.xIndex,
  });

  String get key => '${periodKey}_$agentName';
}

class ReportsScreen extends StatefulWidget {
  const ReportsScreen({super.key});

  @override
  State<ReportsScreen> createState() => _ReportsScreenState();
}

class _ReportsScreenState extends State<ReportsScreen> {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  DateTimeRange _dateRange = DateTimeRange(
    start: DateTime.now().subtract(const Duration(days: 30)),
    end: DateTime.now(),
  );
  String _groupBy = 'day';
  bool _isLoading = false;
  List<String> _allAgents = [];
  List<String> _selectedAgents = [];
  bool _selectAllAgents = true;
  Map<String, String> _agentIdToNameMap = {};
  List<SalesChartData> _salesData = [];
  List<BarChartGroupData> _barChartData = [];
  ChartType _selectedChartType = ChartType.bar;
  int _touchedPieIndex = -1;
  final List<Color> _chartColors = [
    Colors.blue,
    Colors.green,
    Colors.orange,
    Colors.red,
    Colors.purple,
    Colors.teal,
    Colors.amber,
    Colors.deepOrange,
  ];

  @override
  void initState() {
    super.initState();
    _loadInitialData();
  }

  Future<void> _loadInitialData() async {
    await _fetchAgents();
    await _loadChartData();
  }

  Future<void> _fetchAgents() async {
    try {
      final snapshot = await _firestore.collection('users')
          .where('role', isEqualTo: 'agent')
          .get();
      
      setState(() {
        _agentIdToNameMap = {
          for (var doc in snapshot.docs) 
            doc.id: doc['name'] as String
        };
        _allAgents = _agentIdToNameMap.values.toList();
        _selectedAgents = List.from(_allAgents);
      });
    } catch (e) {
      _handleError('Error fetching agents: $e');
    }
  }

  Future<void> _loadChartData() async {
    if (!mounted) return;
    
    setState(() => _isLoading = true);
    try {
      _salesData = await _getChartData();
      _barChartData = _convertToBarChartData(_salesData);
    } catch (e) {
      _handleError('Error loading chart data: $e');
      setState(() {
        _salesData = [];
        _barChartData = [];
      });
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  List<BarChartGroupData> _convertToBarChartData(List<SalesChartData> salesData) {
    return salesData.map((data) {
      return BarChartGroupData(
        x: data.xIndex,
        barRods: [
          BarChartRodData(
            toY: data.amount,
            color: _getColorForIndex(data.xIndex),
            width: 16,
            borderRadius: BorderRadius.circular(4),
          ),
        ],
        showingTooltipIndicators: [0],
      );
    }).toList();
  }

  Future<List<SalesChartData>> _getChartData() async {
    try {
      Query query = _firestore.collectionGroup('sales')
        .where('date', isGreaterThanOrEqualTo: _dateRange.start)
        .where('date', isLessThanOrEqualTo: _dateRange.end);

      if (!_selectAllAgents && _selectedAgents.isNotEmpty) {
        final agentIds = _selectedAgents.map((name) => 
          _agentIdToNameMap.keys.firstWhere((id) => _agentIdToNameMap[id] == name))
          .toList();
        query = query.where('agentId', whereIn: agentIds);
      }

      final QuerySnapshot snapshot = await query.orderBy('date').get();
      final Map<String, double> groupedData = {};

      for (final doc in snapshot.docs) {
        try {
          final date = (doc['date'] as Timestamp).toDate();
          final amount = (doc['totalAmount'] as num?)?.toDouble() ?? 0.0;
          final agentId = doc['agentId'] as String? ?? '';
          final agentName = _agentIdToNameMap[agentId] ?? 'Unknown';
          final periodKey = _getPeriodKey(date);
          final groupKey = '${periodKey}_$agentName';
          
          groupedData.update(
            groupKey,
            (value) => value + amount,
            ifAbsent: () => amount,
          );
        } catch (e) {
          debugPrint('Error processing document ${doc.id}: $e');
        }
      }

      final groupKeys = groupedData.keys.toList();
      return groupedData.entries.map((entry) {
        final parts = entry.key.split('_');
        return SalesChartData(
          periodKey: parts[0],
          agentName: parts.length > 1 ? parts[1] : 'Unknown',
          amount: entry.value,
          xIndex: groupKeys.indexOf(entry.key),
        );
      }).toList();
    } catch (e) {
      debugPrint('Error fetching chart data: $e');
      return [];
    }
  }

  Color _getColorForIndex(int index) {
    return _chartColors[index % _chartColors.length];
  }

  Color _getColorForAgent(String agentName) {
    final index = _allAgents.indexOf(agentName);
    return index >= 0 ? _getColorForIndex(index) : Colors.grey;
  }

  Future<Map<String, Map<String, double>>> _getExportData() async {
    try {
      Query query = _firestore.collectionGroup('sales')
        .where('date', isGreaterThanOrEqualTo: _dateRange.start)
        .where('date', isLessThanOrEqualTo: _dateRange.end);

      if (!_selectAllAgents && _selectedAgents.isNotEmpty) {
        final agentIds = _selectedAgents.map((name) => 
          _agentIdToNameMap.keys.firstWhere((id) => _agentIdToNameMap[id] == name))
          .toList();
        query = query.where('agentId', whereIn: agentIds);
      }

      final QuerySnapshot snapshot = await query.orderBy('date').get();
      final Map<String, Map<String, double>> exportData = {};

      for (final doc in snapshot.docs) {
        final date = (doc['date'] as Timestamp).toDate();
        final amount = (doc['totalAmount'] as num).toDouble();
        final agentId = doc['agentId'] as String;
        final agentName = _agentIdToNameMap[agentId] ?? 'Unknown';
        final periodKey = _getPeriodKey(date);

        exportData.putIfAbsent(periodKey, () => {});
        exportData[periodKey]!.update(
          agentName,
          (value) => value + amount,
          ifAbsent: () => amount,
        );
      }

      return exportData;
    } catch (e) {
      debugPrint('Error fetching export data: $e');
      return {};
    }
  }

  String _getPeriodKey(DateTime date) {
    switch (_groupBy) {
      case 'day':
        return DateFormat('yyyy-MM-dd').format(date);
      case 'week':
        return 'Week ${DateFormat('w').format(date)}';
      case 'month':
        return DateFormat('yyyy-MM').format(date);
      default:
        return DateFormat('yyyy-MM-dd').format(date);
    }
  }

  Future<Directory> _getSafeDownloadDirectory() async {
    try {
      if (Platform.isAndroid) {
        final status = await Permission.manageExternalStorage.request();
        if (!status.isGranted) throw Exception('Permission denied');
        
        final directories = await getExternalStorageDirectories(
          type: StorageDirectory.downloads
        );
        if (directories == null || directories.isEmpty) {
          throw Exception('Downloads directory not found');
        }
        return directories.first;
      } else if (Platform.isIOS) {
        final directory = await getDownloadsDirectory();
        if (directory == null) throw Exception('Downloads directory not available');
        return directory;
      }
      return await getTemporaryDirectory();
    } catch (e) {
      debugPrint('Error accessing download directory: $e');
      return await getTemporaryDirectory();
    }
  }

  Future<void> _exportToExcel() async {
    setState(() => _isLoading = true);
    try {
      final data = await _getExportData();
      if (data.isEmpty) {
        _showSnackBar('No data to export');
        return;
      }

      final workbook = xlsio.Workbook();
      final sheet = workbook.worksheets[0];

      sheet.getRangeByName('A1').setText('Period');
      int col = 1;
      final allAgents = _selectAllAgents ? _allAgents : _selectedAgents;
      for (final agent in allAgents) {
        sheet.getRangeByIndex(1, ++col).setText(agent);
      }
      sheet.getRangeByIndex(1, ++col).setText('Total');
      sheet.getRangeByName('A1:${_getExcelColumnName(col)}1').cellStyle.bold = true;

      int row = 2;
      data.forEach((period, agentData) {
        sheet.getRangeByIndex(row, 1).setText(period);
        double rowTotal = 0;
        col = 1;
        for (final agent in allAgents) {
          final amount = agentData[agent] ?? 0;
          sheet.getRangeByIndex(row, ++col).setNumber(amount);
          rowTotal += amount;
        }
        sheet.getRangeByIndex(row, ++col).setNumber(rowTotal);
        row++;
      });

      sheet.getRangeByIndex(row, 1).setText('TOTAL');
      col = 1;
      for (final agent in allAgents) {
        final colLetter = _getExcelColumnName(++col);
        sheet.getRangeByName('$colLetter$row').setFormula('SUM(${colLetter}2:${colLetter}${row-1})');
      }
      final totalCol = _getExcelColumnName(++col);
      sheet.getRangeByName('${totalCol}$row').setFormula('SUM(${totalCol}2:${totalCol}${row-1})');
      sheet.getRangeByName('A$row:$totalCol$row').cellStyle.bold = true;
      sheet.getRangeByName('A1:$totalCol$row').autoFitColumns();

      final bytes = workbook.saveAsStream();
      workbook.dispose();

      final directory = await _getSafeDownloadDirectory();
      final fileName = 'SalesReport_${DateFormat('yyyyMMdd_HHmmss').format(DateTime.now())}.xlsx';
      final file = File('${directory.path}/$fileName');
      await file.writeAsBytes(bytes);
      await OpenFile.open(file.path);

      _showSnackBar('Exported to $fileName');
    } catch (e) {
      _handleError('Export failed: ${e.toString()}');
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  Future<void> _exportToPDF() async {
    setState(() => _isLoading = true);
    try {
      final data = await _getExportData();
      if (data.isEmpty) {
        _showSnackBar('No data to export');
        return;
      }

      final pdf = pw.Document();
      final allAgents = _selectAllAgents ? _allAgents : _selectedAgents;

      pdf.addPage(
        pw.Page(
          pageFormat: PdfPageFormat.a4,
          build: (pw.Context context) {
            return pw.Column(
              children: [
                pw.Header(
                  level: 0,
                  child: pw.Text(
                    'Sales Report',
                    style: pw.TextStyle(fontSize: 24, fontWeight: pw.FontWeight.bold),
                  ),
                ),
                pw.Text(
                  'Date Range: ${DateFormat('MMM dd, yyyy').format(_dateRange.start)} - '
                  '${DateFormat('MMM dd, yyyy').format(_dateRange.end)}',
                  style: const pw.TextStyle(fontSize: 12),
                ),
                if (!_selectAllAgents)
                  pw.Text(
                    'Agents: ${_selectedAgents.join(', ')}',
                    style: const pw.TextStyle(fontSize: 12),
                  ),
                pw.SizedBox(height: 20),
                pw.Table.fromTextArray(
                  context: context,
                  headers: ['Period', ...allAgents, 'Total'],
                  data: data.entries.map((entry) {
                    final period = entry.key;
                    final agentData = entry.value;
                    final total = agentData.values.fold(0.0, (sum, amount) => sum + amount);

                    return [
                      period,
                      ...allAgents.map((agent) => agentData[agent]?.toStringAsFixed(2) ?? '0.00'),
                      total.toStringAsFixed(2)
                    ];
                  }).toList(),
                  cellStyle: const pw.TextStyle(fontSize: 10),
                  headerStyle: pw.TextStyle(fontSize: 12, fontWeight: pw.FontWeight.bold),
                ),
              ],
            );
          },
        ),
      );

      final directory = await _getSafeDownloadDirectory();
      final fileName = 'SalesReport_${DateFormat('yyyyMMdd_HHmmss').format(DateTime.now())}.pdf';
      final file = File('${directory.path}/$fileName');
      await file.writeAsBytes(await pdf.save());
      await OpenFile.open(file.path);

      _showSnackBar('Exported to $fileName');
    } catch (e) {
      _handleError('Export failed: ${e.toString()}');
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  String _getExcelColumnName(int column) {
    String name = '';
    while (column > 0) {
      column--;
      name = '${String.fromCharCode(65 + column % 26)}$name';
      column = column ~/ 26;
    }
    return name;
  }

  Future<void> _showAgentFilterDialog() async {
    await showDialog(
      context: context,
      builder: (context) {
        return StatefulBuilder(
          builder: (context, setState) {
            return AlertDialog(
              title: const Text('Filter by Agent'),
              content: SingleChildScrollView(
                child: Column(
                  children: [
                    CheckboxListTile(
                      title: const Text('All Agents'),
                      value: _selectAllAgents,
                      onChanged: (value) {
                        setState(() {
                          _selectAllAgents = value ?? true;
                          if (_selectAllAgents) {
                            _selectedAgents = List.from(_allAgents);
                          }
                        });
                      },
                    ),
                    const Divider(),
                    ..._allAgents.map((agent) {
                      return CheckboxListTile(
                        title: Text(agent),
                        value: _selectedAgents.contains(agent),
                        onChanged: _selectAllAgents
                            ? null
                            : (value) {
                                setState(() {
                                  if (value ?? false) {
                                    _selectedAgents.add(agent);
                                  } else {
                                    _selectedAgents.remove(agent);
                                  }
                                });
                              },
                      );
                    }).toList(),
                  ],
                ),
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Text('Cancel'),
                ),
                TextButton(
                  onPressed: () {
                    Navigator.pop(context);
                    _loadChartData();
                  },
                  child: const Text('Apply'),
                ),
              ],
            );
          },
        );
      },
    );
  }

  Future<void> _selectDateRange(BuildContext context) async {
    final DateTimeRange? picked = await showDateRangePicker(
      context: context,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
      initialDateRange: _dateRange,
    );
    
    if (picked != null && picked != _dateRange) {
      setState(() => _dateRange = picked);
      await _loadChartData();
    }
  }

  Widget _buildChart() {
    return Expanded(
      child: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _salesData.isEmpty
              ? const Center(child: Text('No sales data available'))
              : _buildSelectedChart(),
    );
  }

  Widget _buildSelectedChart() {
    switch (_selectedChartType) {
      case ChartType.line:
        return _buildLineChart();
      case ChartType.pie:
        return _buildPieChart();
      case ChartType.bar:
      default:
        return _buildBarChart();
    }
  }

  Widget _buildBarChart() {
    return BarChart(
      BarChartData(
        alignment: BarChartAlignment.spaceAround,
        barGroups: _barChartData,
        titlesData: FlTitlesData(
          leftTitles: AxisTitles(
            sideTitles: SideTitles(
              showTitles: true,
              getTitlesWidget: (value, meta) {
                return Text(value.toInt().toString());
              },
              reservedSize: 40,
            ),
          ),
          bottomTitles: AxisTitles(
            sideTitles: SideTitles(
              showTitles: true,
              getTitlesWidget: (value, meta) {
                final index = value.toInt();
                if (index >= 0 && index < _salesData.length) {
                  return Padding(
                    padding: const EdgeInsets.only(top: 8.0),
                    child: Text(
                      _salesData[index].periodKey,
                      style: const TextStyle(fontSize: 10),
                    ),
                  );
                }
                return const Text('');
              },
              reservedSize: 32,
            ),
          ),
        ),
        gridData: FlGridData(show: true),
        borderData: FlBorderData(show: false),
        barTouchData: BarTouchData(
          enabled: true,
          touchTooltipData: BarTouchTooltipData(
            getTooltipColor: (group) => Colors.blueGrey,
            getTooltipItem: (group, groupIndex, rod, rodIndex) {
              final data = _salesData[groupIndex];
              return BarTooltipItem(
                '${data.periodKey}\n${data.agentName}\n',
                const TextStyle(color: Colors.white),
                children: [
                  TextSpan(
                    text: '\$${rod.toY.toStringAsFixed(2)}',
                    style: const TextStyle(
                      color: Colors.yellow,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ],
              );
            },
          ),
        ),
      ),
    );
  }

  Widget _buildLineChart() {
    return LineChart(
      LineChartData(
        lineBarsData: [
          LineChartBarData(
            spots: _salesData.asMap().entries.map((e) {
              return FlSpot(e.key.toDouble(), e.value.amount);
            }).toList(),
            isCurved: true,
            color: Colors.blue,
            barWidth: 4,
            belowBarData: BarAreaData(show: false),
            dotData: FlDotData(show: true),
          ),
        ],
        titlesData: FlTitlesData(
          leftTitles: AxisTitles(
            sideTitles: SideTitles(
              showTitles: true,
              getTitlesWidget: (value, meta) {
                return Text(value.toInt().toString());
              },
              reservedSize: 40,
            ),
          ),
          bottomTitles: AxisTitles(
            sideTitles: SideTitles(
              showTitles: true,
              getTitlesWidget: (value, meta) {
                final index = value.toInt();
                if (index >= 0 && index < _salesData.length) {
                  return Padding(
                    padding: const EdgeInsets.only(top: 8.0),
                    child: Text(
                      _salesData[index].periodKey,
                      style: const TextStyle(fontSize: 10),
                    ),
                  );
                }
                return const Text('');
              },
              reservedSize: 32,
            ),
          ),
        ),
        gridData: FlGridData(show: true),
        borderData: FlBorderData(show: true),
      ),
    );
  }

  Widget _buildPieChart() {
    final Map<String, double> agentTotals = {};
    for (final data in _salesData) {
      agentTotals.update(
        data.agentName,
        (value) => value + data.amount,
        ifAbsent: () => data.amount,
      );
    }

    final List<PieChartSectionData> pieSections = agentTotals.entries.map((e) {
      final isTouched = _touchedPieIndex == agentTotals.keys.toList().indexOf(e.key);
      return PieChartSectionData(
        color: _getColorForAgent(e.key),
        value: e.value,
        title: '${e.value.toStringAsFixed(0)}\n${e.key}',
        radius: isTouched ? 60 : 50,
        titleStyle: TextStyle(
          fontSize: isTouched ? 16 : 14,
          fontWeight: FontWeight.bold,
          color: Colors.white,
        ),
      );
    }).toList();

    return PieChart(
      PieChartData(
        pieTouchData: PieTouchData(
          touchCallback: (FlTouchEvent event, pieTouchResponse) {
            setState(() {
              if (!event.isInterestedForInteractions ||
                  pieTouchResponse == null ||
                  pieTouchResponse.touchedSection == null) {
                _touchedPieIndex = -1;
                return;
              }
              _touchedPieIndex = pieTouchResponse.touchedSection!.touchedSectionIndex;
            });
          },
        ),
        borderData: FlBorderData(show: false),
        sectionsSpace: 0,
        centerSpaceRadius: 60,
        sections: pieSections,
      ),
    );
  }

  void _handleError(String message) {
    debugPrint(message);
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(message)),
      );
    }
  }

  void _showSnackBar(String message) {
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(message)),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Sales Reports'),
        actions: [
          IconButton(
            icon: const Icon(Icons.filter_alt),
            onPressed: _showAgentFilterDialog,
            tooltip: 'Filter by Agent',
          ),
          IconButton(
            icon: const Icon(Icons.date_range),
            onPressed: () => _selectDateRange(context),
            tooltip: 'Select Date Range',
          ),
          PopupMenuButton<String>(
            icon: const Icon(Icons.group_work),
            onSelected: (value) {
              setState(() => _groupBy = value);
              _loadChartData();
            },
            itemBuilder: (context) => [
              const PopupMenuItem<String>(
                value: 'day',
                child: Text('Daily'),
              ),
              const PopupMenuItem<String>(
                value: 'week',
                child: Text('Weekly'),
              ),
              const PopupMenuItem<String>(
                value: 'month',
                child: Text('Monthly'),
              ),
            ],
          ),
          PopupMenuButton<ChartType>(
            icon: const Icon(Icons.show_chart),
            onSelected: (type) => setState(() => _selectedChartType = type),
            itemBuilder: (context) => [
              const PopupMenuItem<ChartType>(
                value: ChartType.bar,
                child: Text('Bar Chart'),
              ),
              const PopupMenuItem<ChartType>(
                value: ChartType.line,
                child: Text('Line Chart'),
              ),
              const PopupMenuItem<ChartType>(
                value: ChartType.pie,
                child: Text('Pie Chart'),
              ),
            ],
          ),
          PopupMenuButton<String>(
            icon: const Icon(Icons.download),
            onSelected: (value) {
              if (value == 'excel') _exportToExcel();
              if (value == 'pdf') _exportToPDF();
            },
            itemBuilder: (context) => [
              const PopupMenuItem<String>(
                value: 'excel',
                child: Text('Export to Excel'),
              ),
              const PopupMenuItem<String>(
                value: 'pdf',
                child: Text('Export to PDF'),
              ),
            ],
          ),
        ],
      ),
      body: Column(
        children: [
          Text(
            'Sales Report: ${DateFormat('MMM dd, yyyy').format(_dateRange.start)} - '
            '${DateFormat('MMM dd, yyyy').format(_dateRange.end)}',
            style: Theme.of(context).textTheme.titleMedium,
          ),
          if (!_selectAllAgents)
            Padding(
              padding: const EdgeInsets.only(top: 8.0),
              child: Text(
                'Agents: ${_selectedAgents.join(', ')}',
                style: Theme.of(context).textTheme.bodySmall,
              ),
            ),
          const SizedBox(height: 16),
          _buildChart(),
        ],
      ),
    );
  }
}

views\admin\stock_management.dart:

# views\admin\stock_management.dart
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:intl/intl.dart';
import 'package:provider/provider.dart';
import 'package:mobile_scanner/mobile_scanner.dart';
import 'package:salesgo/viewmodels/auth_vm.dart';


class StockManagement extends StatefulWidget {
  const StockManagement({super.key});

  @override
  _StockManagementState createState() => _StockManagementState();
}

class _StockManagementState extends State<StockManagement> {
  String? _selectedLocationId;
  final _formKey = GlobalKey<FormState>();
  final _productController = TextEditingController();
  final _quantityController = TextEditingController();
  List<Map<String, dynamic>> _products = [];
  Map<String, dynamic>? _selectedProduct;
  bool _isScanning = false;
  bool _isProcessingBarcode = false; // Prevent duplicate scans
  late MobileScannerController _scannerController;
  bool _isLoadingProducts = true; // Track product loading state

  @override
  void initState() {
    super.initState();
    _scannerController = MobileScannerController();
    _loadProducts();
  }

  @override
  void dispose() {
    _productController.dispose();
    _quantityController.dispose();
    _scannerController.dispose();
    super.dispose();
  }

  Future<void> _loadProducts() async {
    try {
      final snapshot = await FirebaseFirestore.instance
          .collection('products')
          .get();
      
      if (mounted) {
        setState(() {
          _products = snapshot.docs.map((doc) {
            final data = doc.data();
            return {
              'id': doc.id,
              'name': data['name'] ?? 'Unknown Product',
              'barcode': data['barcode'] ?? '',
              'category': data['category'] ?? '',
            };
          }).toList();
          _isLoadingProducts = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() => _isLoadingProducts = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to load products: ${e.toString()}')),
        );
      }
    }
  }

  void _toggleScanning() {
    if (_isProcessingBarcode) return;
    
    setState(() {
      _isScanning = !_isScanning;
      if (_isScanning) {
        _scannerController.start();
      } else {
        _scannerController.stop();
      }
    });
  }

  void _handleBarcodeScan(BarcodeCapture capture) {
    if (_isProcessingBarcode || capture.barcodes.isEmpty) return;
    
    final barcode = capture.barcodes.first.rawValue;
    if (barcode == null || barcode.isEmpty) return;

    setState(() => _isProcessingBarcode = true);

    try {
      // Find product in preloaded data
      final product = _products.firstWhere(
        (p) => p['barcode'] == barcode,
        orElse: () => {},
      );

      if (mounted) {
        if (product.isNotEmpty) {
          setState(() {
            _selectedProduct = product;
            _productController.text = '${product['name']} (${product['barcode']})';
            _isScanning = false;
          });
          _scannerController.stop();
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Product not found for this barcode')),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error processing barcode: ${e.toString()}')),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isProcessingBarcode = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final authVM = Provider.of<AuthViewModel>(context, listen: false);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Stock Management'),
        actions: [
          IconButton(
            icon: _isScanning 
                ? const Icon(Icons.cancel, color: Colors.red)
                : const Icon(Icons.qr_code_scanner),
            onPressed: _isProcessingBarcode ? null : _toggleScanning,
          ),
        ],
      ),
      body: Stack(
        children: [
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              children: [
                // Scanner overlay
                if (_isScanning)
                  Container(
                    height: 200,
                    decoration: BoxDecoration(
                      border: Border.all(color: Colors.blue),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Stack(
                      children: [
                        MobileScanner(
                          controller: _scannerController,
                          onDetect: _handleBarcodeScan,
                        ),
                        if (_isProcessingBarcode)
                          const Center(
                            child: CircularProgressIndicator(),
                          ),
                      ],
                    ),
                  ),
                if (_isScanning) const SizedBox(height: 16),
                
                // Location Selection Dropdown
                StreamBuilder<QuerySnapshot>(
                  stream: FirebaseFirestore.instance.collection('locations').snapshots(),
                  builder: (context, snapshot) {
                    if (!snapshot.hasData) return const CircularProgressIndicator();
                    
                    return DropdownButtonFormField<String>(
                      value: _selectedLocationId,
                      decoration: const InputDecoration(
                        labelText: 'Select Location',
                        border: OutlineInputBorder(),
                      ),
                      items: snapshot.data!.docs.map((doc) {
                        final location = doc.data() as Map<String, dynamic>;
                        return DropdownMenuItem<String>(
                          value: doc.id,
                          child: Text('${location['name']} (${location['type']})'),
                        );
                      }).toList(),
                      onChanged: (value) => setState(() => _selectedLocationId = value),
                      validator: (value) => value == null ? 'Please select a location' : null,
                    );
                  },
                ),
                const SizedBox(height: 20),
                
                // Stock Assignment Form
                Form(
                  key: _formKey,
                  child: Column(
                    children: [
                      Autocomplete<Map<String, dynamic>>(
                        optionsBuilder: (TextEditingValue textEditingValue) {
                          if (textEditingValue.text.isEmpty) {
                            return const Iterable<Map<String, dynamic>>.empty();
                          }
                          return _products.where((product) => 
                            product['name'].toLowerCase().contains(textEditingValue.text.toLowerCase()) ||
                            (product['barcode']?.toString() ?? '').contains(textEditingValue.text)
                          );
                        },
                        onSelected: (Map<String, dynamic> selection) {
                          setState(() {
                            _selectedProduct = selection;
                            _productController.text = '${selection['name']} (${selection['barcode']})';
                          });
                        },
                        displayStringForOption: (Map<String, dynamic> option) => 
                          '${option['name']} (${option['barcode']})',
                        fieldViewBuilder: (
                          BuildContext context,
                          TextEditingController textEditingController,
                          FocusNode focusNode,
                          VoidCallback onFieldSubmitted,
                        ) {
                          // Sync the internal controller with our _productController
                          _productController.addListener(() {
                            if (_productController.text != textEditingController.text) {
                              textEditingController.text = _productController.text;
                            }
                          });

                          return TextFormField(
                            controller: textEditingController, // Use the Autocomplete's controller
                            focusNode: focusNode,
                            decoration: const InputDecoration(
                              labelText: 'Search Product',
                              border: OutlineInputBorder(),
                            ),
                            validator: (value) {
                              if (value == null || value.isEmpty) {
                                return 'Please select a product';
                              }
                              return null;
                            },
                          );
                        },
                        optionsViewBuilder: (
                          BuildContext context,
                          AutocompleteOnSelected<Map<String, dynamic>> onSelected,
                          Iterable<Map<String, dynamic>> options,
                        ) {
                          return Align(
                            alignment: Alignment.topLeft,
                            child: Material(
                              elevation: 4.0,
                              child: SizedBox(
                                height: 200,
                                child: ListView.builder(
                                  padding: EdgeInsets.zero,
                                  itemCount: options.length,
                                  itemBuilder: (BuildContext context, int index) {
                                    final product = options.elementAt(index);
                                    return InkWell(
                                      onTap: () {
                                        onSelected(product);
                                        _productController.text = '${product['name']} (${product['barcode']})';
                                      },
                                      child: Padding(
                                        padding: const EdgeInsets.all(16.0),
                                        child: Column(
                                          crossAxisAlignment: CrossAxisAlignment.start,
                                          children: [
                                            Text(
                                              product['name'],
                                              style: const TextStyle(fontWeight: FontWeight.bold),
                                            ),
                                            Text('Barcode: ${product['barcode']}'),
                                          ],
                                        ),
                                      ),
                                    );
                                  },
                                ),
                              ),
                            ),
                          );
                        },
                      ),
                      const SizedBox(height: 16),
                      TextFormField(
                        controller: _quantityController,
                        keyboardType: TextInputType.number,
                        decoration: const InputDecoration(
                          labelText: 'Quantity',
                          border: OutlineInputBorder(),
                        ),
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return 'Please enter quantity';
                          }
                          if (int.tryParse(value) == null) {
                            return 'Please enter a valid number';
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 20),
                      ElevatedButton(
                        onPressed: _assignStock,
                        style: ElevatedButton.styleFrom(
                          minimumSize: const Size(double.infinity, 50),
                        ),
                        child: const Text('Assign Stock'),
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 20),
                const Divider(),
                
                // Stock History Section (Admin Only)
                if (authVM.userRole == 'admin')
                  Expanded(
                    child: Column(
                      children: [
                        const Text(
                          'Stock History',
                          style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                        ),
                        const SizedBox(height: 10),
                        Expanded(
                          child: StreamBuilder<QuerySnapshot>(
                            stream: FirebaseFirestore.instance
                                .collection('stockHistory')
                                .orderBy('timestamp', descending: true)
                                .snapshots(),
                            builder: (context, snapshot) {
                              if (!snapshot.hasData) {
                                return const Center(child: CircularProgressIndicator());
                              }
                              
                              return ListView.builder(
                                itemCount: snapshot.data!.docs.length,
                                itemBuilder: (context, index) {
                                  final doc = snapshot.data!.docs[index];
                                  final data = doc.data() as Map<String, dynamic>;
                                  
                                  return FutureBuilder(
                                    future: Future.wait([
                                      FirebaseFirestore.instance
                                          .collection('locations')
                                          .doc(data['locationId'])
                                          .get(),
                                      FirebaseFirestore.instance
                                          .collection('products')
                                          .doc(data['productId'])
                                          .get(),
                                      FirebaseFirestore.instance
                                          .collection('users')
                                          .doc(data['adminId'])
                                          .get(),
                                    ]),
                                    builder: (context, AsyncSnapshot<List<DocumentSnapshot>> snapshot) {
                                      if (!snapshot.hasData) {
                                        return const ListTile(
                                          title: Text('Loading...'),
                                        );
                                      }
                                      
                                      final location = snapshot.data![0].data() as Map<String, dynamic>? ?? {};
                                      final product = snapshot.data![1].data() as Map<String, dynamic>? ?? {};
                                      final admin = snapshot.data![2].data() as Map<String, dynamic>? ?? {};
                                      
                                      return Card(
                                        margin: const EdgeInsets.symmetric(vertical: 4),
                                        child: ListTile(
                                          title: Text(product['name'] ?? 'Unknown Product'),
                                          subtitle: Column(
                                            crossAxisAlignment: CrossAxisAlignment.start,
                                            children: [
                                              Text('Location: ${location['name']} (${location['type']})'),
                                              Text('Quantity: ${data['quantity']}'),
                                              Text('Admin: ${admin['email']}'),
                                            ],
                                          ),
                                          trailing: Text(
                                            data['timestamp'] != null 
                                                ? DateFormat('dd/MM/yy HH:mm').format(
                                                    (data['timestamp'] as Timestamp).toDate(),
                                                  )
                                                : 'No date', // Fallback for null timestamp
                                          ),
                                        ),
                                      );
                                    },
                                  );
                                },
                              );
                            },
                          ),
                        ),
                      ],
                    ),
                  ),
              ],
            ),
          ),
          if (_isLoadingProducts)
            const Center(child: CircularProgressIndicator()),
        ],
      ),
    );
  }

  Future<void> _assignStock() async {
    if (_selectedLocationId == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select a location')),
      );
      return;
    }

    if (_selectedProduct == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select a product')),
      );
      return;
    }

    if (_formKey.currentState!.validate()) {
      final productId = _selectedProduct!['id'];
      final quantity = int.parse(_quantityController.text);
      final authVM = Provider.of<AuthViewModel>(context, listen: false);

      try {
        // Verify admin role before proceeding
        if (authVM.userRole != 'admin') {
          throw Exception('Only administrators can assign stock');
        }

        // Use batch write for atomic operations
        final batch = FirebaseFirestore.instance.batch();

        // 1. Update stock quantity
        final stockRef = FirebaseFirestore.instance
            .collection('locations')
            .doc(_selectedLocationId)
            .collection('stock')
            .doc(productId);
        batch.set(stockRef, {
          'quantity': quantity,
          'lastUpdated': FieldValue.serverTimestamp(),
          'updatedBy': authVM.currentUser?.uid,
        });

        // 2. Add to stock history
        final historyRef = FirebaseFirestore.instance
            .collection('stockHistory')
            .doc();
        batch.set(historyRef, {
          'locationId': _selectedLocationId,
          'productId': productId,
          'productName': _selectedProduct!['name'], // Added product name for better tracking
          'previousQuantity': FieldValue.increment(0), // Placeholder if you want to track changes
          'quantity': quantity,
          'timestamp': FieldValue.serverTimestamp(),
          'adminId': authVM.currentUser?.uid,
          'adminName': authVM.currentUser?.name ?? 'Admin',
        });

        // Execute both operations atomically
        await batch.commit();

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Stock updated successfully')),
        );

        // Clear form
        _productController.clear();
        _quantityController.clear();
        setState(() => _selectedProduct = null);
        FocusScope.of(context).unfocus();
      } catch (e) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error updating stock: ${e.toString()}'),
            duration: const Duration(seconds: 5),
          ),
        );
      }
    }
  }

}

views\admin\users_management.dart:

# views\admin\users_management.dart
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:provider/provider.dart';
import '../../viewmodels/auth_vm.dart';

class UsersScreen extends StatelessWidget {
  const UsersScreen({super.key});

  @override
  Widget build(BuildContext context) {
    Provider.of<AuthViewModel>(context);

    return Scaffold(
      appBar: AppBar(title: const Text('Agent Management')),
      floatingActionButton: FloatingActionButton(
        child: const Icon(Icons.add),
        onPressed: () => _createNewUser(context),
      ),
      body: StreamBuilder<QuerySnapshot>(
        stream: FirebaseFirestore.instance
            .collection('users')
            .where('role', isEqualTo: 'agent')
            .snapshots(),
        builder: (context, snapshot) {
          if (!snapshot.hasData) return const CircularProgressIndicator();
          
          return ListView.builder(
            itemCount: snapshot.data!.docs.length,
            itemBuilder: (context, index) {
              final user = snapshot.data!.docs[index];
              return ListTile(
                title: Text(user['email']),
                trailing: IconButton(
                  icon: const Icon(Icons.delete),
                  onPressed: () => _deleteUser(user.id),
                ),
              );
            },
          );
        },
      ),
    );
  }

  void _createNewUser(BuildContext context) {
    // Navigation vers l'écran de création d'utilisateur
  }

  void _deleteUser(String userId) async {
    await FirebaseFirestore.instance.collection('users').doc(userId).delete();
  }
}

views\agent\agent_home_screen.dart:

# views\agent\agent_home_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:salesgo/viewmodels/auth_vm.dart';
import 'package:salesgo/viewmodels/discount_vm.dart';
import 'package:salesgo/viewmodels/stock_vm.dart';
import 'sales_screen.dart';
import 'stock_screen.dart';
import 'sales_history_screen.dart';

class AgentHomeScreen extends StatefulWidget {
  const AgentHomeScreen({super.key});

  @override
  State<AgentHomeScreen> createState() => _AgentHomeScreenState();
}

class _AgentHomeScreenState extends State<AgentHomeScreen> {
  int _selectedIndex = 0;

  @override
  void initState() {
    super.initState();
    // Initialize viewmodels when screen loads
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final stockVM = context.read<StockViewModel>();
      final discountVM = context.read<DiscountViewModel>();
      final authVM = context.read<AuthViewModel>();
      
      // Load stock for the assigned location (if any)
      if (authVM.currentUser?.assignedLocationId != null) {
        stockVM.loadStock(authVM.currentUser!.assignedLocationId!);
      }
      
      // Load active discounts
      discountVM.loadActiveDiscounts();
    });
  }

  static const List<Widget> _agentScreens = [
    SalesScreen(),
    StockScreen(),
    HistoryScreen(),
  ];

  void _onItemTapped(int index) {
    setState(() => _selectedIndex = index);
  }

  void _logout(BuildContext context) async {
    final authVM = Provider.of<AuthViewModel>(context, listen: false);
    await authVM.signOut();
    Navigator.pushReplacementNamed(context, '/');
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Coach Mobile Dashboard'),
        actions: [
          IconButton(
            icon: const Icon(Icons.logout),
            onPressed: () => _logout(context),
          ),
        ],
      ),
      body: _agentScreens.elementAt(_selectedIndex),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _selectedIndex,
        onTap: _onItemTapped,
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.point_of_sale),
            label: 'Sales',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.inventory_2),
            label: 'Stock',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.history),
            label: 'History',
          ),
        ],
      ),
    );
  }
}

views\agent\refund_screen.dart:

# views\agent\refund_screen.dart
import 'package:flutter/material.dart';
import 'package:mobile_scanner/mobile_scanner.dart';
import 'package:provider/provider.dart';
import 'package:salesgo/services/firestore_service.dart';
import 'package:salesgo/viewmodels/auth_vm.dart';
import 'package:salesgo/viewmodels/refund_vm.dart';
import 'package:salesgo/widgets/product_details_card.dart';
import 'package:salesgo/widgets/refund_product_card.dart';

class RefundScreen extends StatefulWidget {
  const RefundScreen({super.key});

  @override
  State<RefundScreen> createState() => _RefundScreenState();
}

class _RefundScreenState extends State<RefundScreen> {
  final MobileScannerController _scannerController = MobileScannerController();
  final FirestoreService _firestoreService = FirestoreService();
  bool _isScanning = false;
  bool _isProcessingRefund = false;
  bool _hasScanned = false;

  @override
  void dispose() {
    _scannerController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final refundVM = Provider.of<RefundViewModel>(context);
    final authVM = Provider.of<AuthViewModel>(context, listen: false);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Process Refund'),
        actions: [
          IconButton(
            icon: Icon(_isScanning ? Icons.no_photography : Icons.qr_code_scanner),
            onPressed: _toggleScanning,
          ),
        ],
      ),
      body: Stack(
        children: [
          Column(
            children: [
              if (_isScanning) _buildScannerSection(context, refundVM),
              Expanded(
                child: ListView.builder(
                  itemCount: refundVM.refundItems.length,
                  itemBuilder: (context, index) => RefundProductCard(
                    product: refundVM.refundItems[index],
                    onRemove: () {
                      refundVM.removeFromRefund(index);
                      if (refundVM.refundItems.isEmpty) {
                        setState(() => _hasScanned = false);
                      }
                    },
                  ),
                ),
              ),
              if (refundVM.refundItems.isNotEmpty)
                _buildRefundControls(context, refundVM, authVM),
            ],
          ),
          if (_isProcessingRefund)
            const Center(child: CircularProgressIndicator()),
        ],
      ),
    );
  }

  Widget _buildScannerSection(BuildContext context, RefundViewModel refundVM) {
    return Container(
      height: 200,
      decoration: BoxDecoration(
        border: Border.all(color: Colors.grey),
        borderRadius: BorderRadius.circular(8),
      ),
      child: MobileScanner(
        controller: _scannerController,
        onDetect: (capture) {
          if (!_hasScanned) {
            _handleBarcodeScan(capture, context, refundVM);
          }
        },
      ),
    );
  }

  Widget _buildRefundControls(BuildContext context, RefundViewModel refundVM, AuthViewModel authVM) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 8,
            offset: const Offset(0, -4),
          ),
        ],
      ),
      child: Column(
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text('Total Refund:', style: TextStyle(fontSize: 18)),
              Text(
                '€${refundVM.totalRefundAmount.toStringAsFixed(2)}',
                style: const TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              Expanded(
                child: OutlinedButton(
                  onPressed: () => refundVM.clearRefund(),
                  child: const Text('Clear'),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.red, // Red color for refund action
                  ),
                  onPressed: () => _processRefund(context, refundVM, authVM),
                  child: const Text('Process Refund'),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  void _handleBarcodeScan(
    BarcodeCapture capture,
    BuildContext context,
    RefundViewModel refundVM,
  ) async {
    if (capture.barcodes.isEmpty || _hasScanned) return;

    final barcode = capture.barcodes.first.rawValue;
    if (barcode == null) return;

    setState(() {
      _hasScanned = true;
      _isScanning = false;
    });
    _scannerController.stop();

    try {
      final product = await _firestoreService.getProductByBarcode(barcode);
      if (product == null) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Product not found')),
        );
        setState(() => _hasScanned = false);
        return;
      }

      refundVM.addToRefund(product);
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error: ${e.toString()}')),
      );
      setState(() => _hasScanned = false);
    }
  }

  void _toggleScanning() {
    setState(() {
      _isScanning = !_isScanning;
      if (_isScanning) {
        _hasScanned = false;
        _scannerController.start();
      } else {
        _scannerController.stop();
      }
    });
  }

  Future<void> _processRefund(
    BuildContext context,
    RefundViewModel refundVM,
    AuthViewModel authVM,
  ) async {
    if (authVM.currentUser == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('User not authenticated')),
      );
      return;
    }

    if (refundVM.refundItems.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('No items to refund')),
      );
      return;
    }

    setState(() => _isProcessingRefund = true);

    try {
      // Implement your refund logic here
      // Example: await _firestoreService.processRefund(...);
      
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Refund processed successfully!')),
      );

      refundVM.clearRefund();
      setState(() {
        _isScanning = true;
        _isProcessingRefund = false;
        _hasScanned = false;
      });
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error processing refund: ${e.toString()}')),
      );
    } finally {
      if (mounted) {
        setState(() => _isProcessingRefund = false);
      }
    }
  }
}

views\agent\sales_history_screen.dart:

# views\agent\sales_history_screen.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:provider/provider.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:salesgo/models/product.dart';
import 'package:salesgo/models/sale.dart';
import '../../viewmodels/auth_vm.dart';
import '../../widgets/sale_item.dart';

class ProductSalesData {
  List<Sale> sales;
  int totalQuantity;
  double totalAmount;
  final Product product;

  ProductSalesData({
    required this.product,
    List<Sale>? sales,
    this.totalQuantity = 0,
    this.totalAmount = 0.0,
  }) : sales = sales ?? [];
}

class CategorySalesData {
  final List<Sale> sales;
  int totalQuantity;
  double totalAmount;
  final String categoryId;
  String? categoryName;

  CategorySalesData({
    required this.categoryId,
    List<Sale>? sales,
    this.totalQuantity = 0,
    this.totalAmount = 0.0,
  }) : sales = sales ?? [];
}

class DiscountSalesData {
  final List<Sale> sales;
  int totalQuantity;
  double totalAmount;
  final String discountName;

  DiscountSalesData({
    required this.discountName,
    List<Sale>? sales,
    this.totalQuantity = 0,
    this.totalAmount = 0.0,
  }) : sales = sales ?? [];
}

class HistoryScreen extends StatefulWidget {
  const HistoryScreen({super.key});

  @override
  State<HistoryScreen> createState() => _HistoryScreenState();
}

class _HistoryScreenState extends State<HistoryScreen> {
  String _selectedFilter = 'day';
  String _groupBy = 'product';
  late DateTimeRange _dateRange;

  @override
  void initState() {
    super.initState();
    _updateDateRange();
  }

  void _updateDateRange() {
    final now = DateTime.now();
    switch (_selectedFilter) {
      case 'day':
        _dateRange = DateTimeRange(
          start: DateTime(now.year, now.month, now.day),
          end: now,
        );
        break;
      case 'week':
        _dateRange = DateTimeRange(
          start: now.subtract(const Duration(days: 7)),
          end: now,
        );
        break;
      case 'month':
        _dateRange = DateTimeRange(
          start: DateTime(now.year, now.month, 1),
          end: now,
        );
        break;
      default:
        _dateRange = DateTimeRange(
          start: now.subtract(const Duration(days: 7)),
          end: now,
        );
    }
  }

  @override
  Widget build(BuildContext context) {
    final authVM = Provider.of<AuthViewModel>(context);
    final userId = authVM.currentUser?.uid;

    if (userId == null) {
      return const Center(child: Text('User not authenticated'));
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Sales History'),
        actions: [
          PopupMenuButton<String>(
            icon: const Icon(Icons.filter_alt),
            tooltip: 'Group by',
            onSelected: (value) => setState(() => _groupBy = value),
            itemBuilder: (context) {
              final options = {
                'none': 'No grouping',
                'product': 'Group by product',
                'category': 'Group by category',
                'discount': 'Group by discount',
                'payment': 'Group by payment method',
              };

              return options.entries.map((entry) {
                return PopupMenuItem<String>(
                  value: entry.key,
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(entry.value),
                      if (_groupBy == entry.key)
                        const Icon(Icons.check, color: Colors.blueAccent),
                    ],
                  ),
                );
              }).toList();
            },
          ),

          DropdownButton<String>(
            value: _selectedFilter,
            icon: const Icon(Icons.date_range),
            style: const TextStyle(color: Color.fromARGB(255, 0, 0, 0)),
            dropdownColor: const Color.fromARGB(255, 255, 255, 255),            
            items: const [
              DropdownMenuItem(value: 'day', child: Text('Today')),
              DropdownMenuItem(value: 'week', child: Text('This Week')),
              DropdownMenuItem(value: 'month', child: Text('This Month')),
            ],
            onChanged: (value) => setState(() {
              _selectedFilter = value!;
              _updateDateRange();
            }),
          ),
        ],
      ),
      body: StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
        stream: FirebaseFirestore.instance
            .collection('sales')
            .where('agentId', isEqualTo: userId)
            .where('date', isGreaterThanOrEqualTo: _dateRange.start)
            .where('date', isLessThanOrEqualTo: _dateRange.end)
            .orderBy('date', descending: true)
            .snapshots(),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
            return const Center(child: Text('No sales found'));
          }

          final sales = snapshot.data!.docs.map((doc) {
            try {
              return Sale.fromFirestore(doc);
            } catch (e) {
              debugPrint('Error parsing sale: $e');
              return null;
            }
          }).whereType<Sale>().toList();

          switch (_groupBy) {
            case 'none': return _buildSalesList(sales);
            case 'product': return _buildGroupedByProduct(sales);
            case 'category': return _buildGroupedByCategory(sales);
            case 'discount': return _buildGroupedByDiscount(sales);
            case 'payment': return _buildGroupedByPayment(sales);
            default: return _buildSalesList(sales);
          }
        },
      ),
    );
  }

  Widget _buildSalesList(List<Sale> sales) {
    return ListView.builder(
      itemCount: sales.length,
      itemBuilder: (context, index) => SaleItem(sale: sales[index]),
    );
  }

  Widget _buildGroupedByProduct(List<Sale> sales) {
    final productGroups = <String, ProductSalesData>{};
    
    for (final sale in sales) {
      final productsInSale = <String, int>{}; // <productId, quantity>

      for (final product in sale.products) {
        productsInSale.update(product.id, (value) => value + 1, ifAbsent: () => 1);
      }

      for (final entry in productsInSale.entries) {
        final productId = entry.key;
        final quantity = entry.value;
        final product = sale.products.firstWhere((p) => p.id == productId);

        productGroups.putIfAbsent(productId, () => ProductSalesData(
          product: product,
          sales: [],
        ));

        // Ajoute une seule fois la vente
        productGroups[productId]!.sales.add(sale);

        // Calcule correctement la quantité
        productGroups[productId]!.totalQuantity += quantity;
        productGroups[productId]!.totalAmount += product.price * quantity;
      }
    }


    return ListView(
      children: productGroups.entries.map((entry) {
        final data = entry.value;
        return ExpansionTile(
          leading: data.product.imageUrl != null 
              ? Image.network(data.product.imageUrl!, width: 40, height: 40)
              : const Icon(Icons.shopping_bag),
          title: Text(data.product.name),
          subtitle: Text('${data.totalQuantity} items - Total: €${data.totalAmount.toStringAsFixed(2)}'),
          children: [
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  FutureBuilder<DocumentSnapshot>(
                    future: data.product.categoryRef.get(),
                    builder: (context, snapshot) {
                      if (snapshot.hasData) {
                        final category = snapshot.data!.get('name') ?? 'Uncategorized';
                        return Text('Category: $category');
                      }
                      return const Text('Category: Loading...');
                    },
                  ),
                  //Text('Category: ${data.product.categoryRef}'),
                  Text('Unit price: €${data.product.price.toStringAsFixed(2)}'),
                  const SizedBox(height: 8),
                  const Text('Recent sales:', style: TextStyle(fontWeight: FontWeight.bold)),
                  ...data.sales.take(3).map((sale) {
                    final quantityInSale = sale.products.where((p) => p.id == data.product.id).length;
                    return ListTile(
                      contentPadding: EdgeInsets.zero,
                      title: Text('Sale #${sale.id.substring(0, 6)}'),
                      subtitle: Text(DateFormat('MMM dd, HH:mm').format(sale.date)),
                      trailing: Text('$quantityInSale × €${data.product.price.toStringAsFixed(2)}'),
                    );
                  }).toList(),
                  if (data.sales.length > 3)
                    Padding(
                      padding: const EdgeInsets.only(top: 8.0),
                      child: Text('+ ${data.sales.length - 3} more transactions',
                          style: TextStyle(color: Colors.grey[600])),
                    ),
                ],
              ),
            ),
          ],
        );
      }).toList(),
    );
  }

  Widget _buildGroupedByCategory(List<Sale> sales) {
    final categoryGroups = <String, CategorySalesData>{};
    
    // Group sales by category
    for (final sale in sales) {
      final categoryQuantities = <String, int>{};
      final categoryAmounts = <String, double>{};
      final productsByCategory = <String, Product>{};

      for (final product in sale.products) {
        final categoryId = product.categoryRef.id;

        categoryQuantities.update(categoryId, (value) => value + 1, ifAbsent: () => 1);
        categoryAmounts.update(categoryId, (value) => value + product.price, ifAbsent: () => product.price);
        
        // Sauvegarder un produit par catégorie pour le prix (on peut en prendre un arbitraire)
        productsByCategory[categoryId] = product;
      }

      for (final categoryId in categoryQuantities.keys) {
        categoryGroups.putIfAbsent(categoryId, () => CategorySalesData(
          categoryId: categoryId,
          sales: [],
        ));

        categoryGroups[categoryId]!.sales.add(sale);
        categoryGroups[categoryId]!.totalQuantity += categoryQuantities[categoryId]!;
        categoryGroups[categoryId]!.totalAmount += categoryAmounts[categoryId]!;
      }
    }


    return ListView(
      children: categoryGroups.entries.map((entry) {
        final data = entry.value;
        
        return FutureBuilder<DocumentSnapshot>(
          future: data.categoryId.contains('/')
              ? FirebaseFirestore.instance.doc(data.categoryId).get()
              : FirebaseFirestore.instance.collection('categories').doc(data.categoryId).get(),
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.waiting) {
              return const ListTile(
                leading: Icon(Icons.category),
                title: Text('Loading...'),
              );
            }

            String categoryName = 'Uncategorized';
            if (snapshot.hasData && snapshot.data!.exists) {
              categoryName = snapshot.data!.get('name') ?? 'Uncategorized';
            }

            return ExpansionTile(
              leading: const Icon(Icons.category),
              title: Text(categoryName),
              subtitle: Text(
                '${data.totalQuantity} items - Total: €${data.totalAmount.toStringAsFixed(2)}',
              ),
              children: [
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        'Top products:',
                        style: TextStyle(fontWeight: FontWeight.bold),
                      ),
                      const SizedBox(height: 8),
                      FutureBuilder<List<Product>>(
                        future: _getTopProductsInCategory(sales, data.categoryId),
                        builder: (context, productSnapshot) {
                          if (!productSnapshot.hasData) {
                            return const Center(child: CircularProgressIndicator());
                          }
                          return Column(
                            children: productSnapshot.data!.take(3).map((product) {
                              return ListTile(
                                contentPadding: EdgeInsets.zero,
                                leading: product.imageUrl != null
                                    ? Image.network(
                                        product.imageUrl!,
                                        width: 40,
                                        height: 40,
                                      )
                                    : const Icon(Icons.shopping_bag),
                                title: Text(product.name),
                                subtitle: Text('€${product.price.toStringAsFixed(2)}'),
                              );
                            }).toList(),
                          );
                        },
                      ),
                      const SizedBox(height: 16),
                      const Text(
                        'Recent sales:',
                        style: TextStyle(fontWeight: FontWeight.bold),
                      ),
                      ...data.sales.take(3).map((sale) {
                        final quantityInCategory = sale.products
                            .where((p) => p.categoryRef.id == data.categoryId)
                            .length;
                        final amountInCategory = sale.products
                            .where((p) => p.categoryRef.id == data.categoryId)
                            .fold(0.0, (sum, p) => sum + p.price);
                        
                        return ListTile(
                          contentPadding: EdgeInsets.zero,
                          title: Text('Sale #${sale.id.substring(0, 6)}'),
                          subtitle: Text(
                            DateFormat('MMM dd, HH:mm').format(sale.date),
                          ),
                          trailing: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Text('$quantityInCategory items'),
                              Text('€${amountInCategory.toStringAsFixed(2)}'),
                            ],
                          ),
                        );
                      }).toList(),
                      if (data.sales.length > 3)
                        Padding(
                          padding: const EdgeInsets.only(top: 8.0),
                          child: Text(
                            '+ ${data.sales.length - 3} more transactions',
                            style: TextStyle(color: Colors.grey[600]),
                          ),
                        ),
                    ],
                  ),
                ),
              ],
            );
          },
        );
      }).toList(),
    );

  }

  Future<List<Product>> _getTopProductsInCategory(List<Sale> sales, String categoryId) async {
    final productCounts = <Product, int>{};
    
    for (final sale in sales) {
      for (final product in sale.products.where((p) => p.categoryRef.id == categoryId)) {
        productCounts[product] = (productCounts[product] ?? 0) + 1;
      }
    }
    
    // Sort products by count in descending order
    final sortedProducts = productCounts.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    
    return sortedProducts.map((entry) => entry.key).toList();
  }

  Widget _buildGroupedByDiscount(List<Sale> sales) {
    final discountGroups = <String, DiscountSalesData>{};
    
    for (final sale in sales) {
      final discountName = sale.couponCode ?? 'No discount';
      if (!discountGroups.containsKey(discountName)) {
        discountGroups[discountName] = DiscountSalesData(discountName: discountName);
      }
      
      discountGroups[discountName]!.sales.add(sale);
      discountGroups[discountName]!.totalQuantity += sale.products.length;
      discountGroups[discountName]!.totalAmount += sale.totalAmount;
    }

    return ListView(
      children: discountGroups.entries.map((entry) {
        final data = entry.value;
        
        return ExpansionTile(
          leading: const Icon(Icons.discount),
          title: Text(data.discountName),
          subtitle: Text('${data.totalQuantity} items - Total: €${data.totalAmount.toStringAsFixed(2)}'),
          children: [
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text('Recent sales:', style: TextStyle(fontWeight: FontWeight.bold)),
                  ...data.sales.take(3).map((sale) {
                    return ListTile(
                      contentPadding: EdgeInsets.zero,
                      title: Text('Sale #${sale.id.substring(0, 6)}'),
                      subtitle: Text(DateFormat('MMM dd, HH:mm').format(sale.date)),
                      trailing: Text('€${sale.totalAmount.toStringAsFixed(2)}'),
                    );
                  }).toList(),
                ],
              ),
            ),
          ],
        );
      }).toList(),
    );
  }

  Widget _buildGroupedByPayment(List<Sale> sales) {
    final paymentGroups = <String, List<Sale>>{};
    for (final sale in sales) {
      paymentGroups.putIfAbsent(sale.paymentMethod, () => []).add(sale);
    }

    return ListView(
      children: paymentGroups.entries.map((entry) {
        final paymentMethod = entry.key;
        final paymentSales = entry.value;
        final totalAmount = paymentSales.fold<double>(0, (sum, sale) => sum + sale.totalAmount);

        return ExpansionTile(
          title: Text(paymentMethod.toUpperCase()),
          subtitle: Text('${paymentSales.length} sales - Total: €${totalAmount.toStringAsFixed(2)}'),
          children: paymentSales.map((sale) {
            return ListTile(
              title: Text('Sale #${sale.id.substring(0, 8)}'),
              subtitle: Text(DateFormat('dd/MM/yy HH:mm').format(sale.date)),
              trailing: Text('€${sale.totalAmount.toStringAsFixed(2)}'),
            );
          }).toList(),
        );
      }).toList(),
    );
  }

}

views\agent\sales_screen.dart:

# views\agent\sales_screen.dart
import 'package:flutter/material.dart';
import 'package:mobile_scanner/mobile_scanner.dart';
import 'package:provider/provider.dart';
import 'package:salesgo/services/firestore_service.dart';
import 'package:salesgo/viewmodels/auth_vm.dart';
import 'package:salesgo/viewmodels/sales_vm.dart';
import 'package:salesgo/widgets/product_details_card.dart';
import 'package:salesgo/widgets/payment_section.dart';
import 'package:salesgo/views/agent/sales_history_screen.dart';
import 'package:salesgo/viewmodels/refund_vm.dart';
import 'package:salesgo/widgets/refund_product_card.dart';

class SalesScreen extends StatefulWidget {
  const SalesScreen({super.key});

  @override
  State<SalesScreen> createState() => _SalesScreenState();
}

class _SalesScreenState extends State<SalesScreen> with SingleTickerProviderStateMixin {
  final MobileScannerController _scannerController = MobileScannerController();
  final FirestoreService _firestoreService = FirestoreService();
  bool _isScanning = false;
  bool _isProcessingPayment = false;
  bool _hasScanned = false;
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
    _scannerController.stop(); // Ensure scanner is stopped initially
  }

  @override
  void dispose() {
    _scannerController.dispose();
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final salesVM = Provider.of<SalesViewModel>(context);
    final authVM = Provider.of<AuthViewModel>(context, listen: false);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Quick Sale'),
        bottom: TabBar(
          controller: _tabController,
          tabs: const [
            Tab(icon: Icon(Icons.shopping_cart)),
            Tab(icon: Icon(Icons.history)),
            Tab(icon: Icon(Icons.assignment_return)),
          ],
        ),
        actions: [
          if (_tabController.index == 0) // Only show scanner toggle on sales tab
            IconButton(
              icon: Icon(_isScanning ? Icons.no_photography : Icons.qr_code_scanner),
              onPressed: _toggleScanning,
            ),
        ],
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          // Sales Tab
          _buildSalesTab(context, salesVM, authVM),
          
          // History Tab
          const HistoryScreen(),
          
          // Refund Tab
          _buildRefundTab(),
        ],
      ),
    );
  }

  Widget _buildSalesTab(BuildContext context, SalesViewModel salesVM, AuthViewModel authVM) {
    return Stack(
      children: [
        Column(
          children: [
            if (_isScanning) _buildScannerSection(context, salesVM),
            if (salesVM.cartItems.isEmpty)
              Expanded(
                child: Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Icon(Icons.shopping_cart_outlined,
                          size: 64, color: Colors.grey),
                      const SizedBox(height: 20),
                      Text(
                        _isScanning ? 'Scanning in progress' : 'Ready to Process Sale',
                        style: const TextStyle(fontSize: 20),
                      ),
                      const SizedBox(height: 10),
                      Text(
                        _isScanning ? 'Point camera at barcode' : 'Scan products to add to cart',
                        style: const TextStyle(color: Colors.grey),
                      ),
                      const SizedBox(height: 20),
                      ElevatedButton.icon(
                        icon: Icon(_isScanning ? Icons.stop : Icons.qr_code_scanner),
                        label: Text(_isScanning ? 'Stop Scanning' : 'Start Scanning'),
                        onPressed: _toggleScanning,
                        style: ElevatedButton.styleFrom(
                          backgroundColor: _isScanning ? Colors.red : null,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            if (salesVM.cartItems.isNotEmpty)
              Expanded(
                child: ListView.builder(
                  itemCount: salesVM.cartItems.length,
                  itemBuilder: (context, index) => ProductDetailsCard(
                    cartItem: salesVM.cartItems[index],
                    onRemove: () {
                      salesVM.removeFromCart(index);
                      if (salesVM.cartItems.isEmpty) {
                        setState(() => _hasScanned = false);
                      }
                    },
                  ),
                ),
              ),
            if (salesVM.cartItems.isNotEmpty)
              PaymentSection(
                onConfirm: (method, coupon) => _handleSaleConfirmation(
                  context,
                  salesVM,
                  authVM,
                  method,
                  coupon,
                ),
                totalAmount: salesVM.totalAmount,
                isProcessing: _isProcessingPayment,
              ),
          ],
        ),
        if (_isProcessingPayment)
          const Center(child: CircularProgressIndicator()),
      ],
    );
  }

  Widget _buildRefundTab() {
    return Consumer<AuthViewModel>(
      builder: (context, authVM, _) {
        if (authVM.currentUser == null) {
          return const Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.error_outline, size: 48, color: Colors.red),
                SizedBox(height: 16),
                Text('Authentication Required', style: TextStyle(fontSize: 20)),
                SizedBox(height: 8),
                Text('Please login to process refunds', 
                    style: TextStyle(color: Colors.grey)),
              ],
            ),
          );
        }

        return Consumer<RefundViewModel>(
          builder: (context, refundVM, _) {
            if (refundVM.refundItems.isEmpty) {
              return Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(Icons.assignment_return, 
                      size: 64, color: Colors.grey),
                  const SizedBox(height: 20),
                  const Text('Ready to Process Refund',
                      style: TextStyle(fontSize: 20)),
                  const SizedBox(height: 10),
                  const Text('Scan products to refund',
                      style: TextStyle(color: Colors.grey)),
                  const SizedBox(height: 20),
                  ElevatedButton.icon(
                    icon: const Icon(Icons.qr_code_scanner),
                    label: const Text('Start Scanning'),
                    onPressed: () {
                      // No need to navigate, we'll show the scanner in this tab
                      refundVM.clearRefund();
                      // You might want to set a state to show the scanner here
                    },
                  ),
                ],
              );
            }

            return Column(
              children: [
                // Your scanner widget when active
                // Your refund items list
                Expanded(
                  child: ListView.builder(
                    itemCount: refundVM.refundItems.length,
                    itemBuilder: (context, index) => RefundProductCard(
                      product: refundVM.refundItems[index],
                      onRemove: () => refundVM.removeFromRefund(index),
                    ),
                  ),
                ),

                // Refund summary and action buttons
                Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          const Text('Total Refund:', 
                              style: TextStyle(fontSize: 18)),
                          Text(
                            '€${refundVM.totalRefundAmount.toStringAsFixed(2)}',
                            style: const TextStyle(
                              fontSize: 18,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 16),
                      Row(
                        children: [
                          Expanded(
                            child: OutlinedButton(
                              onPressed: refundVM.clearRefund,
                              child: const Text('Clear'),
                            ),
                          ),
                          const SizedBox(width: 16),
                          Expanded(
                            child: ElevatedButton(
                              style: ElevatedButton.styleFrom(
                                backgroundColor: Colors.red,
                              ),
                              onPressed: () => _processRefund(context, refundVM, authVM),
                              child: const Text('Process Refund'),
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ],
            );
          },
        );
      },
    );
  }

  Future<void> _processRefund(
    BuildContext context,
    RefundViewModel refundVM,
    AuthViewModel authVM,
  ) async {
    if (refundVM.refundItems.isEmpty) return;

    try {
      await refundVM.processRefund(
        agentId: authVM.currentUser!.uid,
        locationId: authVM.currentUser!.assignedLocationId!,
      );
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Refund processed successfully!')),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error processing refund: $e')),
      );
    }
  }

  Widget _buildScannerSection(BuildContext context, SalesViewModel salesVM) {
    return Container(
      height: 200,
      decoration: BoxDecoration(
        border: Border.all(color: Colors.grey),
        borderRadius: BorderRadius.circular(8),
      ),
      child: MobileScanner(
        controller: _scannerController,
        onDetect: (capture) {
          if (!_hasScanned) {
            _handleBarcodeScan(capture, context, salesVM);
          }
        },
      ),
    );
  }

  void _handleBarcodeScan(
    BarcodeCapture capture,
    BuildContext context,
    SalesViewModel salesVM,
  ) async {
    if (capture.barcodes.isEmpty || _hasScanned) return;

    final barcode = capture.barcodes.first.rawValue;
    if (barcode == null) return;

    setState(() {
      _hasScanned = true;
      _isScanning = false;
    });
    _scannerController.stop();

    try {
      final product = await _firestoreService.getProductByBarcode(barcode);
      if (product == null) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Product not found')),
        );
        setState(() => _hasScanned = false);
        return;
      }

      salesVM.addToCart(product);
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error: ${e.toString()}')),
      );
      setState(() => _hasScanned = false);
    }
  }

  void _toggleScanning() {
    setState(() {
      _isScanning = !_isScanning;
      if (_isScanning) {
        _hasScanned = false;
        _scannerController.start();
      } else {
        _scannerController.stop();
      }
    });
  }

  Future<void> _handleSaleConfirmation(
    BuildContext context,
    SalesViewModel salesVM,
    AuthViewModel authVM,
    String paymentMethod,
    String? couponCode,
  ) async {
    if (authVM.currentUser == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('User not authenticated')),
      );
      return;
    }

    setState(() => _isProcessingPayment = true);

    try {
      await salesVM.confirmSale(
        paymentMethod: paymentMethod,
        couponCode: couponCode,
        agentId: authVM.currentUser!.uid,
        locationId: authVM.currentUser!.assignedLocationId!, 
      );

      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Sale completed successfully!')),
      );

      setState(() {
        _isScanning = true;
        _isProcessingPayment = false;
        _hasScanned = false;
      });
      _scannerController.start();
      
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error completing sale: ${e.toString()}')),
      );
    } finally {
      if (mounted) {
        setState(() => _isProcessingPayment = false);
      }
    }
  }
}

views\agent\stock_screen.dart:

# views\agent\stock_screen.dart
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import '../../viewmodels/stock_vm.dart';
import '../../models/product.dart';
import '../../viewmodels/auth_vm.dart';

class StockScreen extends StatefulWidget {
  const StockScreen({super.key});

  @override
  State<StockScreen> createState() => _StockScreenState();
}

class _StockScreenState extends State<StockScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    WidgetsBinding.instance.addPostFrameCallback((_) => _loadData());
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  Future<void> _loadData() async {
    final authVM = Provider.of<AuthViewModel>(context, listen: false);
    final stockVM = Provider.of<StockViewModel>(context, listen: false);
    
    if (authVM.currentUser?.assignedLocationId != null) {
      stockVM.loadStock(authVM.currentUser!.assignedLocationId!);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Stock Management'),
        bottom: TabBar(
          controller: _tabController,
          tabs: const [
            Tab(icon: Icon(Icons.inventory)), 
            Tab(icon: Icon(Icons.history)),
        ],
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _loadData,
          ),
        ],
      ),
      body: Consumer2<AuthViewModel, StockViewModel>(
        builder: (context, authVM, stockVM, _) {
          if (authVM.currentUser == null) {
            return const Center(child: Text('Please log in'));
          }

          if (authVM.currentUser!.assignedLocationId == null) {
            return _buildNoLocationAssigned(authVM);
          }

          return TabBarView(
            controller: _tabController,
            children: [
              _buildCurrentStockTab(stockVM, authVM),
              _buildStockHistoryTab(authVM),
            ],
          );
        },
      ),
    );
  }

  Widget _buildNoLocationAssigned(AuthViewModel authVM) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(Icons.location_off, size: 64, color: Colors.grey),
          const SizedBox(height: 16),
          const Text('No location assigned'),
          const SizedBox(height: 8),
          Text(
            'Contact your administrator to assign a location',
            style: Theme.of(context).textTheme.bodySmall,
          ),
          const SizedBox(height: 16),
          ElevatedButton(
            onPressed:_loadData,
            child: const Text('Refresh'),
          ),
        ],
      ),
    );
  }

  Widget _buildCurrentStockTab(StockViewModel stockVM, AuthViewModel authVM) {
    if (stockVM.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    final adjustedStock = stockVM.adjustedStock;

    if (adjustedStock.isEmpty) {
      return FutureBuilder<DocumentSnapshot>(
        future: FirebaseFirestore.instance
            .collection('locations')
            .doc(authVM.currentUser!.assignedLocationId)
            .get(),
        builder: (context, snapshot) {
          if (!snapshot.hasData) {
            return const Center(child: CircularProgressIndicator());
          }

          final location = snapshot.data!.data() as Map<String, dynamic>? ?? {};
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.inventory_2, size: 64, color: Colors.grey),
                const SizedBox(height: 16),
                Text(
                  'No stock available at ${location['name']}',
                  style: Theme.of(context).textTheme.titleMedium,
                ),
                const SizedBox(height: 8),
                const Text('Scan products to add stock'),
                const SizedBox(height: 16),
                ElevatedButton(
                  onPressed: () => stockVM.loadStock(authVM.currentUser!.assignedLocationId!),
                  child: const Text('Refresh'),
                ),
              ],
            ),
          );
        },
      );
    }

    return RefreshIndicator(
      onRefresh: () async => stockVM.loadStock(authVM.currentUser!.assignedLocationId!),
      child: ListView.builder(
        itemCount: adjustedStock.keys.length,
        itemBuilder: (context, index) {
          final productId = adjustedStock.keys.elementAt(index);
          final quantity = adjustedStock[productId] ?? 0;

          return FutureBuilder<DocumentSnapshot>(
            future: FirebaseFirestore.instance
                .collection('products')
                .doc(productId)
                .get(),
            builder: (context, snapshot) {
              if (snapshot.connectionState == ConnectionState.waiting) {
                return const ListTile(
                  leading: CircularProgressIndicator(),
                  title: Text('Loading product...'),
                );
              }

              if (!snapshot.hasData || !snapshot.data!.exists) {
                return ListTile(
                  leading: const Icon(Icons.error),
                  title: Text('Product ID: $productId'),
                  subtitle: const Text('Not found in database'),
                );
              }

              final product = Product.fromFirestore(snapshot.data!);
              return Card(
                margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                child: ListTile(
                  leading: product.imageUrl != null
                      ? Image.network(product.imageUrl!, width: 50, height: 50)
                      : const Icon(Icons.shopping_bag),
                  title: Text(product.name),
                  subtitle: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text('Available: $quantity'),
                      Text('Initial stock: ${stockVM.stock[productId] ?? 0}'),
                      Text('Sold this month: ${stockVM.monthlySales[productId] ?? 0}'),
                      if (product.barcode.isNotEmpty)
                        Text('Barcode: ${product.barcode}'),
                    ],
                  ),
                  trailing: Text(
                    '€${product.price.toStringAsFixed(2)}',
                    style: const TextStyle(fontWeight: FontWeight.bold),
                  ),
                ),
              );
            },
          );
        },
      ),
    );
  }

  Widget _buildStockHistoryTab(AuthViewModel authVM) {
    return StreamBuilder<QuerySnapshot>(
      stream: FirebaseFirestore.instance
          .collection('stockHistory')
          .where('locationId', isEqualTo: authVM.currentUser!.assignedLocationId)
          .orderBy('timestamp', descending: true)
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }

        if (snapshot.hasError) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.error, size: 64, color: Colors.red),
                const SizedBox(height: 16),
                const Text('Error loading stock history'),
                Text(
                  snapshot.error.toString(),
                  style: Theme.of(context).textTheme.bodySmall,
                ),
                const SizedBox(height: 16),
                ElevatedButton(
                  onPressed: _loadData,
                  child: const Text('Retry'),
                ),
              ],
            ),
          );
        }

        if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
          return FutureBuilder<DocumentSnapshot>(
            future: FirebaseFirestore.instance
                .collection('locations')
                .doc(authVM.currentUser!.assignedLocationId)
                .get(),
            builder: (context, locationSnapshot) {
              if (!locationSnapshot.hasData) {
                return const Center(child: CircularProgressIndicator());
              }

              final location = locationSnapshot.data!.data() as Map<String, dynamic>? ?? {};
              return Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Icon(Icons.history, size: 64, color: Colors.grey),
                    const SizedBox(height: 16),
                    Text(
                      'No stock history at ${location['name']}',
                      style: Theme.of(context).textTheme.titleMedium,
                    ),
                    const SizedBox(height: 8),
                    const Text('Stock changes will appear here'),
                  ],
                ),
              );
            },
          );
        }

        return ListView.builder(
          itemCount: snapshot.data!.docs.length,
          itemBuilder: (context, index) {
            final doc = snapshot.data!.docs[index];
            final data = doc.data() as Map<String, dynamic>;
            final timestamp = (data['timestamp'] as Timestamp).toDate();

            return FutureBuilder(
              future: Future.wait([
                FirebaseFirestore.instance
                    .collection('products')
                    .doc(data['productId'])
                    .get(),
                FirebaseFirestore.instance
                    .collection('users')
                    .doc(data['adminId'])
                    .get(),
              ]),
              builder: (context, AsyncSnapshot<List<DocumentSnapshot>> snap) {
                if (snap.connectionState == ConnectionState.waiting) {
                  return const ListTile(
                    leading: CircularProgressIndicator(),
                    title: Text('Loading history details...'),
                  );
                }

                final product = snap.data?[0].exists ?? false
                    ? Product.fromFirestore(snap.data![0])
                    : null;
                final admin = snap.data?[1].exists ?? false
                    ? snap.data![1].data() as Map<String, dynamic>
                    : null;

                return Card(
                  margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  child: ListTile(
                    leading: FutureBuilder<DocumentSnapshot>(
                      future: FirebaseFirestore.instance
                          .collection('products')
                          .doc(data['productId'])
                          .get(),
                      builder: (context, productSnapshot) {
                        if (productSnapshot.connectionState == ConnectionState.waiting) {
                          return const SizedBox(
                            width: 50,
                            height: 50,
                            child: CircularProgressIndicator(),
                          );
                        }
                        
                        if (!productSnapshot.hasData || !productSnapshot.data!.exists) {
                          return const Icon(Icons.error, color: Colors.red);
                        }

                        final product = Product.fromFirestore(productSnapshot.data!);
                        return product.imageUrl != null
                            ? Image.network(product.imageUrl!, width: 50, height: 50)
                            : const Icon(Icons.shopping_bag);
                      },
                    ),
                    title: FutureBuilder<DocumentSnapshot>(
                      future: FirebaseFirestore.instance
                          .collection('products')
                          .doc(data['productId'])
                          .get(),
                      builder: (context, productSnapshot) {
                        if (productSnapshot.connectionState == ConnectionState.waiting) {
                          return const Text('Loading product...');
                        }
                        
                        if (!productSnapshot.hasData || !productSnapshot.data!.exists) {
                          return Text('Product ID: ${data['productId']}');
                        }

                        final product = Product.fromFirestore(productSnapshot.data!);
                        return Text(product.name);
                      },
                    ),
                    subtitle: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('Quantity: ${data['quantity']}'),
                        if (admin != null)
                          Text('Updated by: ${admin['email']}'),
                        Text(
                          DateFormat('MMM dd, yyyy - HH:mm').format(timestamp),
                          style: Theme.of(context).textTheme.bodySmall,
                        ),
                      ],
                    ),
                    trailing: Icon(
                      (data['quantity'] as int) > 0 ? Icons.add : Icons.remove,
                      color: (data['quantity'] as int) > 0 ? Colors.green : Colors.red,
                    ),
                  ),
                );
              },
            );
          },
        );
      },
    );
  }
}

widgets\discount_badge.dart:

# widgets\discount_badge.dart
import 'package:flutter/material.dart';
import '../models/discount.dart';

class DiscountBadge extends StatelessWidget {
  final Discount discount;
  
  const DiscountBadge({super.key, required this.discount});

  @override
  Widget build(BuildContext context) {
    return Chip(
      backgroundColor: discount.type == '%' ? Colors.amber[100] : Colors.green[100],
      label: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            '${discount.value}${discount.type}',
            style: TextStyle(
              fontWeight: FontWeight.bold,
              color: discount.type == '%' ? Colors.orange[800] : Colors.green[800],
            ),
          ),
          Text(
            'Valide: ${discount.startDate?.day}/${discount.startDate?.month} '
            '- ${discount.endDate?.day}/${discount.endDate?.month}',
            style: const TextStyle(fontSize: 10),
          ),
        ],
      ),
    );
  }
}

widgets\payment_section.dart:

# widgets\payment_section.dart
import 'package:flutter/material.dart';

class PaymentSection extends StatefulWidget {
  final Function(String, String?) onConfirm;
  final double totalAmount;
  final bool isProcessing;

  const PaymentSection({
    Key? key,
    required this.onConfirm,
    required this.totalAmount,
    required this.isProcessing,
  }) : super(key: key);

  @override
  State<PaymentSection> createState() => _PaymentSectionState();
}

class _PaymentSectionState extends State<PaymentSection> {
  String? _selectedPaymentMethod;
  final _couponController = TextEditingController();
  final _formKey = GlobalKey<FormState>();
  bool _isSubmitting = false;

  @override
  void didUpdateWidget(covariant PaymentSection oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Reset submitting state if parent widget changes processing state
    if (oldWidget.isProcessing && !widget.isProcessing) {
      _isSubmitting = false;
    }
  }

  @override
  void dispose() {
    _couponController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.all(16),
      child: AbsorbPointer(
        absorbing: widget.isProcessing || _isSubmitting,
        child: AnimatedOpacity(
          opacity: (widget.isProcessing || _isSubmitting) ? 0.6 : 1.0,
          duration: const Duration(milliseconds: 200),
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Text(
                    'Total: €${widget.totalAmount.toStringAsFixed(2)}',
                    style: const TextStyle(
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 20),
                  DropdownButtonFormField<String>(
                    decoration: InputDecoration(
                      labelText: 'Payment Method*',
                      border: const OutlineInputBorder(),
                      filled: widget.isProcessing || _isSubmitting,
                      fillColor: Colors.grey[100],
                    ),
                    value: _selectedPaymentMethod,
                    items: const [
                      DropdownMenuItem(
                        value: 'cash',
                        child: Text('Cash'),
                      ),
                      DropdownMenuItem(
                        value: 'card',
                        child: Text('Credit Card'),
                      ),
                      DropdownMenuItem(
                        value: 'mobile',
                        child: Text('Mobile Payment'),
                      ),
                    ],
                    validator: (value) =>
                        value == null ? 'Please select payment method' : null,
                    onChanged: (value) {
                      if (mounted) {
                        setState(() {
                          _selectedPaymentMethod = value;
                        });
                      }
                    },
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    controller: _couponController,
                    decoration: InputDecoration(
                      labelText: 'Coupon Code (optional)',
                      border: const OutlineInputBorder(),
                      filled: widget.isProcessing || _isSubmitting,
                      fillColor: Colors.grey[100],
                    ),
                  ),
                  const SizedBox(height: 24),
                  ElevatedButton(
                    style: ElevatedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      backgroundColor: Theme.of(context).primaryColor,
                    ),
                    onPressed: _isSubmitting ? null : _handleConfirmation,
                    child: _isSubmitting
                        ? const SizedBox(
                            width: 20,
                            height: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              color: Colors.white,
                            ),
                          )
                        : const Text(
                            'Confirm Sale',
                            style: TextStyle(fontSize: 16, color: Colors.white),
                          ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _handleConfirmation() async {
    if (!_formKey.currentState!.validate()) return;

    if (!mounted) return;

    setState(() => _isSubmitting = true);

    try {
      await widget.onConfirm(
        _selectedPaymentMethod!,
        _couponController.text.trim().isNotEmpty
            ? _couponController.text.trim()
            : null,
      );
    } finally {
      if (mounted) {
        setState(() => _isSubmitting = false);
      }
    }
  }
}

widgets\product_details_card.dart:

# widgets\product_details_card.dart
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:provider/provider.dart';
import '../models/cart_item.dart';
import '../models/discount.dart';
import '../viewmodels/discount_vm.dart';
import '../viewmodels/sales_vm.dart';
import 'discount_badge.dart';

class ProductDetailsCard extends StatefulWidget {
  final CartItem cartItem;
  final VoidCallback? onRemove;

  const ProductDetailsCard({
    super.key,
    required this.cartItem,
    this.onRemove,
  });

  @override
  State<ProductDetailsCard> createState() => _ProductDetailsCardState();
}

class _ProductDetailsCardState extends State<ProductDetailsCard> {
  Discount? _selectedDiscount;

  @override
  void initState() {
    super.initState();
    _selectedDiscount = widget.cartItem.discount;
  }

  @override
  Widget build(BuildContext context) {
    final discountVM = Provider.of<DiscountViewModel>(context);
    final salesVM = Provider.of<SalesViewModel>(context);

    final product = widget.cartItem.product;

    final applicableDiscounts = discountVM.activeDiscounts
        .where((d) => d.categoryRef.path == product.categoryRef.path)
        .toList();

    final finalPrice = _selectedDiscount != null
        ? _calculatePriceWithDiscount(product.price, _selectedDiscount!)
        : product.price;

    return Card(
      margin: const EdgeInsets.all(12),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header Row
            Row(
              children: [
                // Product Image
                if (product.imageUrl != null && product.imageUrl!.isNotEmpty)
                  ClipRRect(
                    borderRadius: BorderRadius.circular(8),
                    child: Image.network(
                      product.imageUrl!,
                      width: 80,
                      height: 80,
                      fit: BoxFit.cover,
                    ),
                  )
                else
                  Container(
                    width: 80,
                    height: 80,
                    decoration: BoxDecoration(
                      color: Colors.grey[200],
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: const Icon(Icons.image_not_supported, color: Colors.grey),
                  ),
                const SizedBox(width: 16),

                // Product Info
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        product.name,
                        style: Theme.of(context).textTheme.titleLarge?.copyWith(
                              fontWeight: FontWeight.bold,
                            ),
                      ),
                      const SizedBox(height: 4),
                      FutureBuilder<DocumentSnapshot>(
                        future: product.categoryRef.get(),
                        builder: (context, snapshot) {
                          final categoryName =
                              snapshot.hasData ? snapshot.data?.get('name') ?? '' : 'Loading...';
                          return Text(
                            'Category: $categoryName',
                            style: Theme.of(context).textTheme.bodySmall?.copyWith(
                                  color: Colors.grey[600],
                                ),
                          );
                        },
                      ),
                      if (product.barcode.isNotEmpty)
                        Text(
                          'Barcode: ${product.barcode}',
                          style: Theme.of(context).textTheme.bodySmall,
                        ),
                    ],
                  ),
                ),

                // Remove Button
                if (widget.onRemove != null)
                  IconButton(
                    icon: const Icon(Icons.delete, color: Colors.red),
                    onPressed: widget.onRemove,
                  ),
              ],
            ),

            const Divider(height: 24),

            // Discount Dropdown
            if (applicableDiscounts.isNotEmpty) ...[
              Text(
                'Available Discounts:',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 12),
                decoration: BoxDecoration(
                  border: Border.all(color: Colors.grey[300]!),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: DropdownButton<Discount>(
                  isExpanded: true,
                  value: _selectedDiscount,
                  hint: const Text('Select discount...'),
                  underline: const SizedBox(),
                  items: [
                    const DropdownMenuItem<Discount>(
                      value: null,
                      child: Text('No discount'),
                    ),
                    ...applicableDiscounts.map(
                      (discount) => DropdownMenuItem<Discount>(
                        value: discount,
                        child: Text(
                          '${discount.value}${discount.type} discount',
                          style: TextStyle(
                            color: _selectedDiscount == discount
                                ? Theme.of(context).primaryColor
                                : null,
                          ),
                        ),
                      ),
                    ),
                  ],
                  onChanged: (Discount? selected) {
                    setState(() {
                      _selectedDiscount = selected;
                    });
                    salesVM.selectDiscountForCartItem(widget.cartItem.id, selected);
                  },
                ),
              ),
              const SizedBox(height: 16),
            ],

            // Price Display
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Final Price:',
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
                ),
                Text(
                  '€${finalPrice.toStringAsFixed(2)}',
                  style: TextStyle(
                    fontSize: 24,
                    color: Theme.of(context).colorScheme.primary,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),

            if (_selectedDiscount != null)
              Padding(
                padding: const EdgeInsets.only(top: 4),
                child: Text(
                  'Original: €${product.price.toStringAsFixed(2)}',
                  style: TextStyle(
                    fontSize: 14,
                    color: Colors.grey[600],
                    decoration: TextDecoration.lineThrough,
                  ),
                ),
              ),

            if (_selectedDiscount != null) ...[
              const SizedBox(height: 12),
              DiscountBadge(discount: _selectedDiscount!),
            ],
          ],
        ),
      ),
    );
  }

  double _calculatePriceWithDiscount(double basePrice, Discount discount) {
    return discount.type == '%'
        ? basePrice * (1 - discount.value / 100)
        : basePrice - discount.value;
  }
}


widgets\refund_product_card.dart:

# widgets\refund_product_card.dart
import 'package:flutter/material.dart';
import '../models/product.dart';

class RefundProductCard extends StatelessWidget {
  final Product product;
  final VoidCallback? onRemove;

  const RefundProductCard({
    super.key,
    required this.product,
    this.onRemove,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.all(12),
      child: ListTile(
        title: Text(product.name),
        subtitle: Text('Price: €${product.price?.toStringAsFixed(2) ?? 'N/A'}'),
        trailing: IconButton(
          icon: const Icon(Icons.delete, color: Colors.red),
          onPressed: onRemove,
        ),
      ),
    );
  }
}


widgets\role_based_ui.dart:

# widgets\role_based_ui.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../viewmodels/auth_vm.dart';
import '../views/admin/admin_home_screen.dart';
import '../views/agent/agent_home_screen.dart';
import '../views/login_screen.dart'; // Import added

class RoleBasedUI extends StatelessWidget {
  const RoleBasedUI({super.key});

  @override
  Widget build(BuildContext context) {
    final authVM = Provider.of<AuthViewModel>(context);

    if (authVM.userRole == 'admin') {
      return const AdminHomeScreen();
    } else if (authVM.userRole == 'agent') {
      return const AgentHomeScreen();
    } else if (authVM.currentUser == null) {
      // User is not logged in, navigate to login
      return const LoginScreen();
    } else {
      // User is logged in, but role is still being fetched
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }
  }
} 

widgets\sale_item.dart:

# widgets\sale_item.dart
import 'package:flutter/material.dart';
import '../models/sale.dart';

class SaleItem extends StatelessWidget {
  final Sale sale;
  
  const SaleItem({super.key, required this.sale});

  @override
  Widget build(BuildContext context) {
    return Card(
      child: ListTile(
        title: Text('Vente #${sale.id}'),
        subtitle: Text('Total: ${sale.totalAmount}€'),
        trailing: Text(sale.paymentMethod),
      ),
    );
  }
}
